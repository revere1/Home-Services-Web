{"remainingRequest":"D:\\Ramesh\\revere\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!D:\\Ramesh\\revere\\node_modules\\codemirror\\mode\\python\\python.js","dependencies":[{"path":"D:\\Ramesh\\revere\\node_modules\\codemirror\\mode\\python\\python.js","mtime":1527492763064},{"path":"D:\\Ramesh\\revere\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1527492760843},{"path":"D:\\Ramesh\\revere\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1527492734929}],"contextDependencies":[],"result":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n(function (mod) {\n    if (typeof exports == \"object\" && typeof module == \"object\")\n        mod(require(\"../../lib/codemirror\"));\n    else if (typeof define == \"function\" && define.amd)\n        define([\"../../lib/codemirror\"], mod);\n    else\n        mod(CodeMirror);\n})(function (CodeMirror) {\n    \"use strict\";\n    function wordRegexp(words) {\n        return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n    }\n    var wordOperators = wordRegexp([\"and\", \"or\", \"not\", \"is\"]);\n    var commonKeywords = [\"as\", \"assert\", \"break\", \"class\", \"continue\",\n        \"def\", \"del\", \"elif\", \"else\", \"except\", \"finally\",\n        \"for\", \"from\", \"global\", \"if\", \"import\",\n        \"lambda\", \"pass\", \"raise\", \"return\",\n        \"try\", \"while\", \"with\", \"yield\", \"in\"];\n    var commonBuiltins = [\"abs\", \"all\", \"any\", \"bin\", \"bool\", \"bytearray\", \"callable\", \"chr\",\n        \"classmethod\", \"compile\", \"complex\", \"delattr\", \"dict\", \"dir\", \"divmod\",\n        \"enumerate\", \"eval\", \"filter\", \"float\", \"format\", \"frozenset\",\n        \"getattr\", \"globals\", \"hasattr\", \"hash\", \"help\", \"hex\", \"id\",\n        \"input\", \"int\", \"isinstance\", \"issubclass\", \"iter\", \"len\",\n        \"list\", \"locals\", \"map\", \"max\", \"memoryview\", \"min\", \"next\",\n        \"object\", \"oct\", \"open\", \"ord\", \"pow\", \"property\", \"range\",\n        \"repr\", \"reversed\", \"round\", \"set\", \"setattr\", \"slice\",\n        \"sorted\", \"staticmethod\", \"str\", \"sum\", \"super\", \"tuple\",\n        \"type\", \"vars\", \"zip\", \"__import__\", \"NotImplemented\",\n        \"Ellipsis\", \"__debug__\"];\n    CodeMirror.registerHelper(\"hintWords\", \"python\", commonKeywords.concat(commonBuiltins));\n    function top(state) {\n        return state.scopes[state.scopes.length - 1];\n    }\n    CodeMirror.defineMode(\"python\", function (conf, parserConf) {\n        var ERRORCLASS = \"error\";\n        var delimiters = parserConf.delimiters || parserConf.singleDelimiters || /^[\\(\\)\\[\\]\\{\\}@,:`=;\\.\\\\]/;\n        //               (Backwards-compatiblity with old, cumbersome config system)\n        var operators = [parserConf.singleOperators, parserConf.doubleOperators, parserConf.doubleDelimiters, parserConf.tripleDelimiters,\n            parserConf.operators || /^([-+*/%\\/&|^]=?|[<>=]+|\\/\\/=?|\\*\\*=?|!=|[~!@])/];\n        for (var i = 0; i < operators.length; i++)\n            if (!operators[i])\n                operators.splice(i--, 1);\n        var hangingIndent = parserConf.hangingIndent || conf.indentUnit;\n        var myKeywords = commonKeywords, myBuiltins = commonBuiltins;\n        if (parserConf.extra_keywords != undefined)\n            myKeywords = myKeywords.concat(parserConf.extra_keywords);\n        if (parserConf.extra_builtins != undefined)\n            myBuiltins = myBuiltins.concat(parserConf.extra_builtins);\n        var py3 = !(parserConf.version && Number(parserConf.version) < 3);\n        if (py3) {\n            // since http://legacy.python.org/dev/peps/pep-0465/ @ is also an operator\n            var identifiers = parserConf.identifiers || /^[_A-Za-z\\u00A1-\\uFFFF][_A-Za-z0-9\\u00A1-\\uFFFF]*/;\n            myKeywords = myKeywords.concat([\"nonlocal\", \"False\", \"True\", \"None\", \"async\", \"await\"]);\n            myBuiltins = myBuiltins.concat([\"ascii\", \"bytes\", \"exec\", \"print\"]);\n            var stringPrefixes = new RegExp(\"^(([rbuf]|(br)|(fr))?('{3}|\\\"{3}|['\\\"]))\", \"i\");\n        }\n        else {\n            var identifiers = parserConf.identifiers || /^[_A-Za-z][_A-Za-z0-9]*/;\n            myKeywords = myKeywords.concat([\"exec\", \"print\"]);\n            myBuiltins = myBuiltins.concat([\"apply\", \"basestring\", \"buffer\", \"cmp\", \"coerce\", \"execfile\",\n                \"file\", \"intern\", \"long\", \"raw_input\", \"reduce\", \"reload\",\n                \"unichr\", \"unicode\", \"xrange\", \"False\", \"True\", \"None\"]);\n            var stringPrefixes = new RegExp(\"^(([rubf]|(ur)|(br))?('{3}|\\\"{3}|['\\\"]))\", \"i\");\n        }\n        var keywords = wordRegexp(myKeywords);\n        var builtins = wordRegexp(myBuiltins);\n        // tokenizers\n        function tokenBase(stream, state) {\n            var sol = stream.sol() && state.lastToken != \"\\\\\";\n            if (sol)\n                state.indent = stream.indentation();\n            // Handle scope changes\n            if (sol && top(state).type == \"py\") {\n                var scopeOffset = top(state).offset;\n                if (stream.eatSpace()) {\n                    var lineOffset = stream.indentation();\n                    if (lineOffset > scopeOffset)\n                        pushPyScope(state);\n                    else if (lineOffset < scopeOffset && dedent(stream, state) && stream.peek() != \"#\")\n                        state.errorToken = true;\n                    return null;\n                }\n                else {\n                    var style = tokenBaseInner(stream, state);\n                    if (scopeOffset > 0 && dedent(stream, state))\n                        style += \" \" + ERRORCLASS;\n                    return style;\n                }\n            }\n            return tokenBaseInner(stream, state);\n        }\n        function tokenBaseInner(stream, state) {\n            if (stream.eatSpace())\n                return null;\n            // Handle Comments\n            if (stream.match(/^#.*/))\n                return \"comment\";\n            // Handle Number Literals\n            if (stream.match(/^[0-9\\.]/, false)) {\n                var floatLiteral = false;\n                // Floats\n                if (stream.match(/^[\\d_]*\\.\\d+(e[\\+\\-]?\\d+)?/i)) {\n                    floatLiteral = true;\n                }\n                if (stream.match(/^[\\d_]+\\.\\d*/)) {\n                    floatLiteral = true;\n                }\n                if (stream.match(/^\\.\\d+/)) {\n                    floatLiteral = true;\n                }\n                if (floatLiteral) {\n                    // Float literals may be \"imaginary\"\n                    stream.eat(/J/i);\n                    return \"number\";\n                }\n                // Integers\n                var intLiteral = false;\n                // Hex\n                if (stream.match(/^0x[0-9a-f_]+/i))\n                    intLiteral = true;\n                // Binary\n                if (stream.match(/^0b[01_]+/i))\n                    intLiteral = true;\n                // Octal\n                if (stream.match(/^0o[0-7_]+/i))\n                    intLiteral = true;\n                // Decimal\n                if (stream.match(/^[1-9][\\d_]*(e[\\+\\-]?[\\d_]+)?/)) {\n                    // Decimal literals may be \"imaginary\"\n                    stream.eat(/J/i);\n                    // TODO - Can you have imaginary longs?\n                    intLiteral = true;\n                }\n                // Zero by itself with no other piece of number.\n                if (stream.match(/^0(?![\\dx])/i))\n                    intLiteral = true;\n                if (intLiteral) {\n                    // Integer literals may be \"long\"\n                    stream.eat(/L/i);\n                    return \"number\";\n                }\n            }\n            // Handle Strings\n            if (stream.match(stringPrefixes)) {\n                var isFmtString = stream.current().toLowerCase().indexOf('f') !== -1;\n                if (!isFmtString) {\n                    state.tokenize = tokenStringFactory(stream.current());\n                    return state.tokenize(stream, state);\n                }\n                else {\n                    state.tokenize = formatStringFactory(stream.current(), state.tokenize);\n                    return state.tokenize(stream, state);\n                }\n            }\n            for (var i = 0; i < operators.length; i++)\n                if (stream.match(operators[i]))\n                    return \"operator\";\n            if (stream.match(delimiters))\n                return \"punctuation\";\n            if (state.lastToken == \".\" && stream.match(identifiers))\n                return \"property\";\n            if (stream.match(keywords) || stream.match(wordOperators))\n                return \"keyword\";\n            if (stream.match(builtins))\n                return \"builtin\";\n            if (stream.match(/^(self|cls)\\b/))\n                return \"variable-2\";\n            if (stream.match(identifiers)) {\n                if (state.lastToken == \"def\" || state.lastToken == \"class\")\n                    return \"def\";\n                return \"variable\";\n            }\n            // Handle non-detected items\n            stream.next();\n            return ERRORCLASS;\n        }\n        function formatStringFactory(delimiter, tokenOuter) {\n            while (\"rubf\".indexOf(delimiter.charAt(0).toLowerCase()) >= 0)\n                delimiter = delimiter.substr(1);\n            var singleline = delimiter.length == 1;\n            var OUTCLASS = \"string\";\n            function tokenFString(stream, state) {\n                // inside f-str Expression\n                if (stream.match(delimiter)) {\n                    // expression ends pre-maturally, but very common in editing\n                    // Could show error to remind users to close brace here\n                    state.tokenize = tokenString;\n                    return OUTCLASS;\n                }\n                else if (stream.match('{')) {\n                    // starting brace, if not eaten below\n                    return \"punctuation\";\n                }\n                else if (stream.match('}')) {\n                    // return to regular inside string state\n                    state.tokenize = tokenString;\n                    return \"punctuation\";\n                }\n                else {\n                    // use tokenBaseInner to parse the expression\n                    return tokenBaseInner(stream, state);\n                }\n            }\n            function tokenString(stream, state) {\n                while (!stream.eol()) {\n                    stream.eatWhile(/[^'\"\\{\\}\\\\]/);\n                    if (stream.eat(\"\\\\\")) {\n                        stream.next();\n                        if (singleline && stream.eol())\n                            return OUTCLASS;\n                    }\n                    else if (stream.match(delimiter)) {\n                        state.tokenize = tokenOuter;\n                        return OUTCLASS;\n                    }\n                    else if (stream.match('{{')) {\n                        // ignore {{ in f-str\n                        return OUTCLASS;\n                    }\n                    else if (stream.match('{', false)) {\n                        // switch to nested mode\n                        state.tokenize = tokenFString;\n                        if (stream.current()) {\n                            return OUTCLASS;\n                        }\n                        else {\n                            // need to return something, so eat the starting {\n                            stream.next();\n                            return \"punctuation\";\n                        }\n                    }\n                    else if (stream.match('}}')) {\n                        return OUTCLASS;\n                    }\n                    else if (stream.match('}')) {\n                        // single } in f-string is an error\n                        return ERRORCLASS;\n                    }\n                    else {\n                        stream.eat(/['\"]/);\n                    }\n                }\n                if (singleline) {\n                    if (parserConf.singleLineStringErrors)\n                        return ERRORCLASS;\n                    else\n                        state.tokenize = tokenOuter;\n                }\n                return OUTCLASS;\n            }\n            tokenString.isString = true;\n            return tokenString;\n        }\n        function tokenStringFactory(delimiter) {\n            while (\"rubf\".indexOf(delimiter.charAt(0).toLowerCase()) >= 0)\n                delimiter = delimiter.substr(1);\n            var singleline = delimiter.length == 1;\n            var OUTCLASS = \"string\";\n            function tokenString(stream, state) {\n                while (!stream.eol()) {\n                    stream.eatWhile(/[^'\"\\\\]/);\n                    if (stream.eat(\"\\\\\")) {\n                        stream.next();\n                        if (singleline && stream.eol())\n                            return OUTCLASS;\n                    }\n                    else if (stream.match(delimiter)) {\n                        state.tokenize = tokenBase;\n                        return OUTCLASS;\n                    }\n                    else {\n                        stream.eat(/['\"]/);\n                    }\n                }\n                if (singleline) {\n                    if (parserConf.singleLineStringErrors)\n                        return ERRORCLASS;\n                    else\n                        state.tokenize = tokenBase;\n                }\n                return OUTCLASS;\n            }\n            tokenString.isString = true;\n            return tokenString;\n        }\n        function pushPyScope(state) {\n            while (top(state).type != \"py\")\n                state.scopes.pop();\n            state.scopes.push({ offset: top(state).offset + conf.indentUnit,\n                type: \"py\",\n                align: null });\n        }\n        function pushBracketScope(stream, state, type) {\n            var align = stream.match(/^([\\s\\[\\{\\(]|#.*)*$/, false) ? null : stream.column() + 1;\n            state.scopes.push({ offset: state.indent + hangingIndent,\n                type: type,\n                align: align });\n        }\n        function dedent(stream, state) {\n            var indented = stream.indentation();\n            while (state.scopes.length > 1 && top(state).offset > indented) {\n                if (top(state).type != \"py\")\n                    return true;\n                state.scopes.pop();\n            }\n            return top(state).offset != indented;\n        }\n        function tokenLexer(stream, state) {\n            if (stream.sol())\n                state.beginningOfLine = true;\n            var style = state.tokenize(stream, state);\n            var current = stream.current();\n            // Handle decorators\n            if (state.beginningOfLine && current == \"@\")\n                return stream.match(identifiers, false) ? \"meta\" : py3 ? \"operator\" : ERRORCLASS;\n            if (/\\S/.test(current))\n                state.beginningOfLine = false;\n            if ((style == \"variable\" || style == \"builtin\")\n                && state.lastToken == \"meta\")\n                style = \"meta\";\n            // Handle scope changes.\n            if (current == \"pass\" || current == \"return\")\n                state.dedent += 1;\n            if (current == \"lambda\")\n                state.lambda = true;\n            if (current == \":\" && !state.lambda && top(state).type == \"py\")\n                pushPyScope(state);\n            if (current.length == 1 && !/string|comment/.test(style)) {\n                var delimiter_index = \"[({\".indexOf(current);\n                if (delimiter_index != -1)\n                    pushBracketScope(stream, state, \"])}\".slice(delimiter_index, delimiter_index + 1));\n                delimiter_index = \"])}\".indexOf(current);\n                if (delimiter_index != -1) {\n                    if (top(state).type == current)\n                        state.indent = state.scopes.pop().offset - hangingIndent;\n                    else\n                        return ERRORCLASS;\n                }\n            }\n            if (state.dedent > 0 && stream.eol() && top(state).type == \"py\") {\n                if (state.scopes.length > 1)\n                    state.scopes.pop();\n                state.dedent -= 1;\n            }\n            return style;\n        }\n        var external = {\n            startState: function (basecolumn) {\n                return {\n                    tokenize: tokenBase,\n                    scopes: [{ offset: basecolumn || 0, type: \"py\", align: null }],\n                    indent: basecolumn || 0,\n                    lastToken: null,\n                    lambda: false,\n                    dedent: 0\n                };\n            },\n            token: function (stream, state) {\n                var addErr = state.errorToken;\n                if (addErr)\n                    state.errorToken = false;\n                var style = tokenLexer(stream, state);\n                if (style && style != \"comment\")\n                    state.lastToken = (style == \"keyword\" || style == \"punctuation\") ? stream.current() : style;\n                if (style == \"punctuation\")\n                    style = null;\n                if (stream.eol() && state.lambda)\n                    state.lambda = false;\n                return addErr ? style + \" \" + ERRORCLASS : style;\n            },\n            indent: function (state, textAfter) {\n                if (state.tokenize != tokenBase)\n                    return state.tokenize.isString ? CodeMirror.Pass : 0;\n                var scope = top(state), closing = scope.type == textAfter.charAt(0);\n                if (scope.align != null)\n                    return scope.align - (closing ? 1 : 0);\n                else\n                    return scope.offset - (closing ? hangingIndent : 0);\n            },\n            electricInput: /^\\s*[\\}\\]\\)]$/,\n            closeBrackets: { triples: \"'\\\"\" },\n            lineComment: \"#\",\n            fold: \"indent\"\n        };\n        return external;\n    });\n    CodeMirror.defineMIME(\"text/x-python\", \"python\");\n    var words = function (str) { return str.split(\" \"); };\n    CodeMirror.defineMIME(\"text/x-cython\", {\n        name: \"python\",\n        extra_keywords: words(\"by cdef cimport cpdef ctypedef enum except \" +\n            \"extern gil include nogil property public \" +\n            \"readonly struct union DEF IF ELIF ELSE\")\n    });\n});\n",null]}