{"remainingRequest":"D:\\Ramesh\\revere\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!D:\\Ramesh\\revere\\node_modules\\@angular\\flex-layout\\esm5\\flex-layout.es5.js","dependencies":[{"path":"D:\\Ramesh\\revere\\node_modules\\@angular\\flex-layout\\esm5\\flex-layout.es5.js","mtime":1527492749229},{"path":"D:\\Ramesh\\revere\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1527492760843},{"path":"D:\\Ramesh\\revere\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1527492734929}],"contextDependencies":[],"result":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directive, ElementRef, Inject, Injectable, InjectionToken, Input, IterableDiffers, KeyValueDiffers, NgModule, NgZone, Optional, Renderer2, SecurityContext, Self, SimpleChange, SkipSelf, Version } from '@angular/core';\nimport { DomSanitizer, ɵgetDOM } from '@angular/platform-browser';\nimport { filter, map } from 'rxjs/operators';\nimport { __extends } from 'tslib';\nimport { DOCUMENT, NgClass, NgStyle } from '@angular/common';\nimport { BehaviorSubject } from 'rxjs/BehaviorSubject';\nimport { ReplaySubject } from 'rxjs/ReplaySubject';\n/**\n * Current version of Angular Flex-Layout.\n */\nvar VERSION = new Version('2.0.0-beta.10-4905443');\nvar LAYOUT_VALUES = ['row', 'column', 'row-reverse', 'column-reverse'];\n/**\n * Validate the direction|'direction wrap' value and then update the host's inline flexbox styles\n * @param {?} value\n * @return {?}\n */\nfunction buildLayoutCSS(value) {\n    var _a = validateValue(value), direction = _a[0], wrap = _a[1];\n    return buildCSS(direction, wrap);\n}\n/**\n * Validate the value to be one of the acceptable value options\n * Use default fallback of 'row'\n * @param {?} value\n * @return {?}\n */\nfunction validateValue(value) {\n    value = value ? value.toLowerCase() : '';\n    var _a = value.split(' '), direction = _a[0], wrap = _a[1];\n    if (!LAYOUT_VALUES.find(function (x) { return x === direction; })) {\n        direction = LAYOUT_VALUES[0];\n    }\n    return [direction, validateWrapValue(wrap)];\n}\n/**\n * Determine if the validated, flex-direction value specifies\n * a horizontal/row flow.\n * @param {?} value\n * @return {?}\n */\nfunction isFlowHorizontal(value) {\n    var _a = validateValue(value), flow = _a[0], _ = _a[1];\n    return flow.indexOf('row') > -1;\n}\n/**\n * Convert layout-wrap='<value>' to expected flex-wrap style\n * @param {?} value\n * @return {?}\n */\nfunction validateWrapValue(value) {\n    if (!!value) {\n        switch (value.toLowerCase()) {\n            case 'reverse':\n            case 'wrap-reverse':\n            case 'reverse-wrap':\n                value = 'wrap-reverse';\n                break;\n            case 'no':\n            case 'none':\n            case 'nowrap':\n                value = 'nowrap';\n                break;\n            // All other values fallback to 'wrap'\n            default:\n                value = 'wrap';\n                break;\n        }\n    }\n    return value;\n}\n/**\n * Build the CSS that should be assigned to the element instance\n * BUG:\n *   1) min-height on a column flex container won’t apply to its flex item children in IE 10-11.\n *      Use height instead if possible; height : <xxx>vh;\n *\n *  This way any padding or border specified on the child elements are\n *  laid out and drawn inside that element's specified width and height.\n * @param {?} direction\n * @param {?=} wrap\n * @return {?}\n */\nfunction buildCSS(direction, wrap) {\n    if (wrap === void 0) {\n        wrap = null;\n    }\n    return {\n        'display': 'flex',\n        'box-sizing': 'border-box',\n        'flex-direction': direction,\n        'flex-wrap': !!wrap ? wrap : null\n    };\n}\n/**\n * Applies CSS prefixes to appropriate style keys.\n *\n * Note: `-ms-`, `-moz` and `-webkit-box` are no longer supported. e.g.\n *    {\n *      display: -webkit-flex;     NEW - Safari 6.1+. iOS 7.1+, BB10\n *      display: flex;             NEW, Spec - Firefox, Chrome, Opera\n *      // display: -webkit-box;   OLD - iOS 6-, Safari 3.1-6, BB7\n *      // display: -ms-flexbox;   TWEENER - IE 10\n *      // display: -moz-flexbox;  OLD - Firefox\n *    }\n * @param {?} target\n * @return {?}\n */\nfunction applyCssPrefixes(target) {\n    for (var /** @type {?} */ key in target) {\n        var /** @type {?} */ value = target[key] || '';\n        switch (key) {\n            case 'display':\n                if (value === 'flex') {\n                    target['display'] = [\n                        '-webkit-flex',\n                        'flex'\n                    ];\n                }\n                else if (value === 'inline-flex') {\n                    target['display'] = [\n                        '-webkit-inline-flex',\n                        'inline-flex'\n                    ];\n                }\n                else {\n                    target['display'] = value;\n                }\n                break;\n            case 'align-items':\n            case 'align-self':\n            case 'align-content':\n            case 'flex':\n            case 'flex-basis':\n            case 'flex-flow':\n            case 'flex-grow':\n            case 'flex-shrink':\n            case 'flex-wrap':\n            case 'justify-content':\n                target['-webkit-' + key] = value;\n                break;\n            case 'flex-direction':\n                value = value || 'row';\n                target['-webkit-flex-direction'] = value;\n                target['flex-direction'] = value;\n                break;\n            case 'order':\n                target['order'] = target['-webkit-' + key] = isNaN(value) ? '0' : value;\n                break;\n        }\n    }\n    return target;\n}\n/**\n * Applies styles given via string pair or object map to the directive element.\n * @param {?} renderer\n * @param {?} element\n * @param {?} style\n * @param {?=} value\n * @return {?}\n */\nfunction applyStyleToElement(renderer, element, style, value) {\n    var /** @type {?} */ styles = {};\n    if (typeof style === 'string') {\n        styles[style] = value;\n        style = styles;\n    }\n    styles = applyCssPrefixes(style);\n    applyMultiValueStyleToElement(styles, element, renderer);\n}\n/**\n * Applies styles given via string pair or object map to the directive's element.\n * @param {?} renderer\n * @param {?} style\n * @param {?} elements\n * @return {?}\n */\nfunction applyStyleToElements(renderer, style, elements) {\n    var /** @type {?} */ styles = applyCssPrefixes(style);\n    elements.forEach(function (el) {\n        applyMultiValueStyleToElement(styles, el, renderer);\n    });\n}\n/**\n * Applies the styles to the element. The styles object map may contain an array of values.\n * Each value will be added as element style.\n * Keys are sorted to add prefixed styles (like -webkit-x) first, before the standard ones.\n * @param {?} styles\n * @param {?} element\n * @param {?} renderer\n * @return {?}\n */\nfunction applyMultiValueStyleToElement(styles, element, renderer) {\n    Object.keys(styles).sort().forEach(function (key) {\n        var /** @type {?} */ values = Array.isArray(styles[key]) ? styles[key] : [styles[key]];\n        for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n            var value = values_1[_i];\n            renderer.setStyle(element, key, value);\n        }\n    });\n}\n/**\n * Find the DOM element's raw attribute value (if any)\n * @param {?} element\n * @param {?} attribute\n * @return {?}\n */\nfunction lookupAttributeValue(element, attribute) {\n    return ɵgetDOM().getAttribute(element, attribute) || '';\n}\n/**\n * Find the DOM element's inline style value (if any)\n * @param {?} element\n * @param {?} styleName\n * @return {?}\n */\nfunction lookupInlineStyle(element, styleName) {\n    return ɵgetDOM().getStyle(element, styleName);\n}\n/**\n * Determine the inline or inherited CSS style\n * @param {?} element\n * @param {?} styleName\n * @param {?=} inlineOnly\n * @return {?}\n */\nfunction lookupStyle(element, styleName, inlineOnly) {\n    if (inlineOnly === void 0) {\n        inlineOnly = false;\n    }\n    var /** @type {?} */ value = '';\n    if (element) {\n        try {\n            var /** @type {?} */ immediateValue = value = lookupInlineStyle(element, styleName);\n            if (!inlineOnly) {\n                value = immediateValue || ɵgetDOM().getComputedStyle(element).getPropertyValue(styleName);\n            }\n        }\n        catch (e) {\n            // TODO: platform-server throws an exception for getComputedStyle, will be fixed by PR 18362\n        }\n    }\n    // Note: 'inline' is the default of all elements, unless UA stylesheet overrides;\n    //       in which case getComputedStyle() should determine a valid value.\n    return value ? value.trim() : 'block';\n}\n/**\n * Extends an object with the *enumerable* and *own* properties of one or more source objects,\n * similar to Object.assign.\n *\n * @param {?} dest The object which will have properties copied to it.\n * @param {...?} sources The source objects from which properties will be copied.\n * @return {?}\n */\nfunction extendObject(dest) {\n    var sources = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        sources[_i - 1] = arguments[_i];\n    }\n    if (dest == null) {\n        throw TypeError('Cannot convert undefined or null to object');\n    }\n    for (var _a = 0, sources_1 = sources; _a < sources_1.length; _a++) {\n        var source = sources_1[_a];\n        if (source != null) {\n            for (var /** @type {?} */ key in source) {\n                if (source.hasOwnProperty(key)) {\n                    dest[key] = source[key];\n                }\n            }\n        }\n    }\n    return dest;\n}\nvar KeyOptions = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} baseKey\n     * @param {?} defaultValue\n     * @param {?} inputKeys\n     */\n    function KeyOptions(baseKey, defaultValue, inputKeys) {\n        this.baseKey = baseKey;\n        this.defaultValue = defaultValue;\n        this.inputKeys = inputKeys;\n    }\n    return KeyOptions;\n}());\n/**\n * ResponsiveActivation acts as a proxy between the MonitorMedia service (which emits mediaQuery\n * changes) and the fx API directives. The MQA proxies mediaQuery change events and notifies the\n * directive via the specified callback.\n *\n * - The MQA also determines which directive property should be used to determine the\n *   current change 'value'... BEFORE the original `onMediaQueryChanges()` method is called.\n * - The `ngOnDestroy()` method is also head-hooked to enable auto-unsubscribe from the\n *   MediaQueryServices.\n *\n * NOTE: these interceptions enables the logic in the fx API directives to remain terse and clean.\n */\nvar ResponsiveActivation = /*@__PURE__*/ (function () {\n    /**\n     * Constructor\n     * @param {?} _options\n     * @param {?} _mediaMonitor\n     * @param {?} _onMediaChanges\n     */\n    function ResponsiveActivation(_options, _mediaMonitor, _onMediaChanges) {\n        this._options = _options;\n        this._mediaMonitor = _mediaMonitor;\n        this._onMediaChanges = _onMediaChanges;\n        this._subscribers = [];\n        this._registryMap = this._buildRegistryMap();\n        this._subscribers = this._configureChangeObservers();\n    }\n    Object.defineProperty(ResponsiveActivation.prototype, \"registryFromLargest\", {\n        /**\n         * Get a readonly sorted list of the breakpoints corresponding to the directive properties\n         * defined in the HTML markup: the sorting is done from largest to smallest. The order is\n         * important when several media queries are 'registered' and from which, the browser uses the\n         * first matching media query.\n         * @return {?}\n         */\n        get: function () {\n            return this._registryMap.slice().reverse();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ResponsiveActivation.prototype, \"mediaMonitor\", {\n        /**\n         * Accessor to the DI'ed directive property\n         * Each directive instance has a reference to the MediaMonitor which is\n         * used HERE to subscribe to mediaQuery change notifications.\n         * @return {?}\n         */\n        get: function () {\n            return this._mediaMonitor;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ResponsiveActivation.prototype, \"activatedInputKey\", {\n        /**\n         * Determine which directive \\@Input() property is currently active (for the viewport size):\n         * The key must be defined (in use) or fallback to the 'closest' overlapping property key\n         * that is defined; otherwise the default property key will be used.\n         * e.g.\n         *      if `<div fxHide fxHide.gt-sm=\"false\">` is used but the current activated mediaQuery alias\n         *      key is `.md` then `.gt-sm` should be used instead\n         * @return {?}\n         */\n        get: function () {\n            return this._activatedInputKey || this._options.baseKey;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ResponsiveActivation.prototype, \"activatedInput\", {\n        /**\n         * Get the currently activated \\@Input value or the fallback default \\@Input value\n         * @return {?}\n         */\n        get: function () {\n            var /** @type {?} */ key = this.activatedInputKey;\n            return this.hasKeyValue(key) ? this._lookupKeyValue(key) : this._options.defaultValue;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Fast validator for presence of attribute on the host element\n     * @param {?} key\n     * @return {?}\n     */\n    ResponsiveActivation.prototype.hasKeyValue = function (key) {\n        var /** @type {?} */ value = this._options.inputKeys[key];\n        return typeof value !== 'undefined';\n    };\n    /**\n     * Remove interceptors, restore original functions, and forward the onDestroy() call\n     * @return {?}\n     */\n    ResponsiveActivation.prototype.destroy = function () {\n        this._subscribers.forEach(function (link) {\n            link.unsubscribe();\n        });\n        this._subscribers = [];\n    };\n    /**\n     * For each *defined* API property, register a callback to `_onMonitorEvents( )`\n     * Cache 1..n subscriptions for internal auto-unsubscribes when the the directive destructs\n     * @return {?}\n     */\n    ResponsiveActivation.prototype._configureChangeObservers = function () {\n        var _this = this;\n        var /** @type {?} */ subscriptions = [];\n        this._registryMap.forEach(function (bp) {\n            if (_this._keyInUse(bp.key)) {\n                // Inject directive default property key name: to let onMediaChange() calls\n                // know which property is being triggered...\n                var /** @type {?} */ buildChanges = function (change) {\n                    change = change.clone();\n                    change.property = _this._options.baseKey;\n                    return change;\n                };\n                subscriptions.push(_this.mediaMonitor.observe(bp.alias).pipe(map(buildChanges))\n                    .subscribe(function (change) {\n                    _this._onMonitorEvents(change);\n                }));\n            }\n        });\n        return subscriptions;\n    };\n    /**\n     * Build mediaQuery key-hashmap; only for the directive properties that are actually defined/used\n     * in the HTML markup\n     * @return {?}\n     */\n    ResponsiveActivation.prototype._buildRegistryMap = function () {\n        var _this = this;\n        return this.mediaMonitor.breakpoints\n            .map(function (bp) {\n            return (extendObject({}, bp, {\n                baseKey: _this._options.baseKey,\n                key: _this._options.baseKey + bp.suffix // e.g.  layoutGtSm, layoutMd, layoutGtLg\n            }));\n        })\n            .filter(function (bp) { return _this._keyInUse(bp.key); });\n    };\n    /**\n     * Synchronizes change notifications with the current mq-activated \\@Input and calculates the\n     * mq-activated input value or the default value\n     * @param {?} change\n     * @return {?}\n     */\n    ResponsiveActivation.prototype._onMonitorEvents = function (change) {\n        if (change.property == this._options.baseKey) {\n            change.value = this._calculateActivatedValue(change);\n            this._onMediaChanges(change);\n        }\n    };\n    /**\n     * Has the key been specified in the HTML markup and thus is intended\n     * to participate in activation processes.\n     * @param {?} key\n     * @return {?}\n     */\n    ResponsiveActivation.prototype._keyInUse = function (key) {\n        return this._lookupKeyValue(key) !== undefined;\n    };\n    /**\n     *  Map input key associated with mediaQuery activation to closest defined input key\n     *  then return the values associated with the targeted input property\n     *\n     *  !! change events may arrive out-of-order (activate before deactivate)\n     *     so make sure the deactivate is used ONLY when the keys match\n     *     (since a different activate may be in use)\n     * @param {?} current\n     * @return {?}\n     */\n    ResponsiveActivation.prototype._calculateActivatedValue = function (current) {\n        var /** @type {?} */ currentKey = this._options.baseKey + current.suffix; // e.g. suffix == 'GtSm',\n        var /** @type {?} */ newKey = this._activatedInputKey; // e.g. newKey == hideGtSm\n        newKey = current.matches ? currentKey : ((newKey == currentKey) ? '' : newKey);\n        this._activatedInputKey = this._validateInputKey(newKey);\n        return this.activatedInput;\n    };\n    /**\n     * For the specified input property key, validate it is defined (used in the markup)\n     * If not see if a overlapping mediaQuery-related input key fallback has been defined\n     *\n     * NOTE: scans in the order defined by activeOverLaps (largest viewport ranges -> smallest ranges)\n     * @param {?} inputKey\n     * @return {?}\n     */\n    ResponsiveActivation.prototype._validateInputKey = function (inputKey) {\n        var _this = this;\n        var /** @type {?} */ isMissingKey = function (key) { return !_this._keyInUse(key); };\n        if (isMissingKey(inputKey)) {\n            this.mediaMonitor.activeOverlaps.some(function (bp) {\n                var /** @type {?} */ key = _this._options.baseKey + bp.suffix;\n                if (!isMissingKey(key)) {\n                    inputKey = key;\n                    return true; // exit .some()\n                }\n                return false;\n            });\n        }\n        return inputKey;\n    };\n    /**\n     * Get the value (if any) for the directive instances \\@Input property (aka key)\n     * @param {?} key\n     * @return {?}\n     */\n    ResponsiveActivation.prototype._lookupKeyValue = function (key) {\n        return this._options.inputKeys[key];\n    };\n    return ResponsiveActivation;\n}());\n/**\n * Abstract base class for the Layout API styling directives.\n * @abstract\n */\nvar BaseFxDirective = /*@__PURE__*/ (function () {\n    /**\n     * Constructor\n     * @param {?} _mediaMonitor\n     * @param {?} _elementRef\n     * @param {?} _renderer\n     */\n    function BaseFxDirective(_mediaMonitor, _elementRef, _renderer) {\n        this._mediaMonitor = _mediaMonitor;\n        this._elementRef = _elementRef;\n        this._renderer = _renderer;\n        /**\n         *  Dictionary of input keys with associated values\n         */\n        this._inputMap = {};\n        /**\n         * Has the `ngOnInit()` method fired\n         *\n         * Used to allow *ngFor tasks to finish and support queries like\n         * getComputedStyle() during ngOnInit().\n         */\n        this._hasInitialized = false;\n    }\n    Object.defineProperty(BaseFxDirective.prototype, \"hasMediaQueryListener\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return !!this._mqActivation;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BaseFxDirective.prototype, \"activatedValue\", {\n        /**\n         * Imperatively determine the current activated [input] value;\n         * if called before ngOnInit() this will return `undefined`\n         * @return {?}\n         */\n        get: function () {\n            return this._mqActivation ? this._mqActivation.activatedInput : undefined;\n        },\n        /**\n         * Change the currently activated input value and force-update\n         * the injected CSS (by-passing change detection).\n         *\n         * NOTE: Only the currently activated input value will be modified;\n         *       other input values will NOT be affected.\n         * @param {?} value\n         * @return {?}\n         */\n        set: function (value) {\n            var /** @type {?} */ key = 'baseKey', /** @type {?} */ previousVal;\n            if (this._mqActivation) {\n                key = this._mqActivation.activatedInputKey;\n                previousVal = this._inputMap[key];\n                this._inputMap[key] = value;\n            }\n            var /** @type {?} */ change = new SimpleChange(previousVal, value, false);\n            this.ngOnChanges(/** @type {?} */ (_a = {}, _a[key] = change, _a));\n            var _a;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BaseFxDirective.prototype, \"parentElement\", {\n        /**\n         * Access to host element's parent DOM node\n         * @return {?}\n         */\n        get: function () {\n            return this._elementRef.nativeElement.parentNode;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BaseFxDirective.prototype, \"nativeElement\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return this._elementRef.nativeElement;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Access the current value (if any) of the \\@Input property.\n     * @param {?} key\n     * @return {?}\n     */\n    BaseFxDirective.prototype._queryInput = function (key) {\n        return this._inputMap[key];\n    };\n    /**\n     * Use post-component-initialization event to perform extra\n     * querying such as computed Display style\n     * @return {?}\n     */\n    BaseFxDirective.prototype.ngOnInit = function () {\n        this._display = this._getDisplayStyle();\n        this._hasInitialized = true;\n    };\n    /**\n     * @param {?} change\n     * @return {?}\n     */\n    BaseFxDirective.prototype.ngOnChanges = function (change) {\n        throw new Error(\"BaseFxDirective::ngOnChanges should be overridden in subclass: \" + change);\n    };\n    /**\n     * @return {?}\n     */\n    BaseFxDirective.prototype.ngOnDestroy = function () {\n        if (this._mqActivation) {\n            this._mqActivation.destroy();\n        }\n        this._mediaMonitor = null;\n    };\n    /**\n     * Was the directive's default selector used ?\n     * If not, use the fallback value!\n     * @param {?} key\n     * @param {?} fallbackVal\n     * @return {?}\n     */\n    BaseFxDirective.prototype._getDefaultVal = function (key, fallbackVal) {\n        var /** @type {?} */ val = this._queryInput(key);\n        var /** @type {?} */ hasDefaultVal = (val !== undefined && val !== null);\n        return (hasDefaultVal && val !== '') ? val : fallbackVal;\n    };\n    /**\n     * Quick accessor to the current HTMLElement's `display` style\n     * Note: this allows use to preserve the original style\n     * and optional restore it when the mediaQueries deactivate\n     * @param {?=} source\n     * @return {?}\n     */\n    BaseFxDirective.prototype._getDisplayStyle = function (source) {\n        if (source === void 0) {\n            source = this.nativeElement;\n        }\n        return lookupStyle(source || this.nativeElement, 'display');\n    };\n    /**\n     * Quick accessor to raw attribute value on the target DOM element\n     * @param {?} attribute\n     * @param {?=} source\n     * @return {?}\n     */\n    BaseFxDirective.prototype._getAttributeValue = function (attribute, source) {\n        if (source === void 0) {\n            source = this.nativeElement;\n        }\n        return lookupAttributeValue(source || this.nativeElement, attribute);\n    };\n    /**\n     * Determine the DOM element's Flexbox flow (flex-direction).\n     *\n     * Check inline style first then check computed (stylesheet) style.\n     * And optionally add the flow value to element's inline style.\n     * @param {?} target\n     * @param {?=} addIfMissing\n     * @return {?}\n     */\n    BaseFxDirective.prototype._getFlowDirection = function (target, addIfMissing) {\n        if (addIfMissing === void 0) {\n            addIfMissing = false;\n        }\n        var /** @type {?} */ value = 'row';\n        if (target) {\n            value = lookupStyle(target, 'flex-direction') || 'row';\n            var /** @type {?} */ hasInlineValue = lookupInlineStyle(target, 'flex-direction');\n            if (!hasInlineValue && addIfMissing) {\n                applyStyleToElements(this._renderer, buildLayoutCSS(value), [target]);\n            }\n        }\n        return value.trim();\n    };\n    /**\n     * Applies styles given via string pair or object map to the directive element.\n     * @param {?} style\n     * @param {?=} value\n     * @param {?=} nativeElement\n     * @return {?}\n     */\n    BaseFxDirective.prototype._applyStyleToElement = function (style, value, nativeElement) {\n        if (nativeElement === void 0) {\n            nativeElement = this.nativeElement;\n        }\n        var /** @type {?} */ element = nativeElement || this.nativeElement;\n        applyStyleToElement(this._renderer, element, style, value);\n    };\n    /**\n     * Applies styles given via string pair or object map to the directive's element.\n     * @param {?} style\n     * @param {?} elements\n     * @return {?}\n     */\n    BaseFxDirective.prototype._applyStyleToElements = function (style, elements) {\n        applyStyleToElements(this._renderer, style, elements || []);\n    };\n    /**\n     *  Save the property value; which may be a complex object.\n     *  Complex objects support property chains\n     * @param {?=} key\n     * @param {?=} source\n     * @return {?}\n     */\n    BaseFxDirective.prototype._cacheInput = function (key, source) {\n        if (typeof source === 'object') {\n            for (var /** @type {?} */ prop in source) {\n                this._inputMap[prop] = source[prop];\n            }\n        }\n        else {\n            if (!!key) {\n                this._inputMap[key] = source;\n            }\n        }\n    };\n    /**\n     *  Build a ResponsiveActivation object used to manage subscriptions to mediaChange notifications\n     *  and intelligent lookup of the directive's property value that corresponds to that mediaQuery\n     *  (or closest match).\n     * @param {?} key\n     * @param {?} defaultValue\n     * @param {?} onMediaQueryChange\n     * @return {?}\n     */\n    BaseFxDirective.prototype._listenForMediaQueryChanges = function (key, defaultValue, onMediaQueryChange) {\n        if (!this._mqActivation) {\n            var /** @type {?} */ keyOptions = new KeyOptions(key, defaultValue, this._inputMap);\n            this._mqActivation = new ResponsiveActivation(keyOptions, this._mediaMonitor, function (change) { return onMediaQueryChange(change); });\n        }\n        return this._mqActivation;\n    };\n    Object.defineProperty(BaseFxDirective.prototype, \"childrenNodes\", {\n        /**\n         * Special accessor to query for all child 'element' nodes regardless of type, class, etc.\n         * @return {?}\n         */\n        get: function () {\n            var /** @type {?} */ obj = this.nativeElement.children;\n            var /** @type {?} */ buffer = [];\n            // iterate backwards ensuring that length is an UInt32\n            for (var /** @type {?} */ i = obj.length; i--;) {\n                buffer[i] = obj[i];\n            }\n            return buffer;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Does this directive have 1 or more responsive keys defined\n     * Note: we exclude the 'baseKey' key (which is NOT considered responsive)\n     * @param {?} baseKey\n     * @return {?}\n     */\n    BaseFxDirective.prototype.hasResponsiveAPI = function (baseKey) {\n        var /** @type {?} */ totalKeys = Object.keys(this._inputMap).length;\n        var /** @type {?} */ baseValue = this._inputMap[baseKey];\n        return (totalKeys - (!!baseValue ? 1 : 0)) > 0;\n    };\n    /**\n     * Fast validator for presence of attribute on the host element\n     * @param {?} key\n     * @return {?}\n     */\n    BaseFxDirective.prototype.hasKeyValue = function (key) {\n        return this._mqActivation.hasKeyValue(key);\n    };\n    Object.defineProperty(BaseFxDirective.prototype, \"hasInitialized\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return this._hasInitialized;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return BaseFxDirective;\n}());\n/**\n * Adapter to the BaseFxDirective abstract class so it can be used via composition.\n * @see BaseFxDirective\n */\nvar BaseFxDirectiveAdapter = /*@__PURE__*/ (function (_super) {\n    __extends(BaseFxDirectiveAdapter, _super);\n    /**\n     * BaseFxDirectiveAdapter constructor\n     * @param {?} _baseKey\n     * @param {?} _mediaMonitor\n     * @param {?} _elementRef\n     * @param {?} _renderer\n     */\n    function BaseFxDirectiveAdapter(_baseKey, // non-responsive @Input property name\n    _mediaMonitor, _elementRef, _renderer) {\n        var _this = _super.call(this, _mediaMonitor, _elementRef, _renderer) || this;\n        _this._baseKey = _baseKey;\n        _this._mediaMonitor = _mediaMonitor;\n        _this._elementRef = _elementRef;\n        _this._renderer = _renderer;\n        return _this;\n    }\n    Object.defineProperty(BaseFxDirectiveAdapter.prototype, \"activeKey\", {\n        /**\n         * Accessor to determine which \\@Input property is \"active\"\n         * e.g. which property value will be used.\n         * @return {?}\n         */\n        get: function () {\n            var /** @type {?} */ mqa = this._mqActivation;\n            var /** @type {?} */ key = mqa ? mqa.activatedInputKey : this._baseKey;\n            // Note: ClassDirective::SimpleChanges uses 'klazz' instead of 'class' as a key\n            return (key === 'class') ? 'klazz' : key;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BaseFxDirectiveAdapter.prototype, \"inputMap\", {\n        /**\n         * Hash map of all \\@Input keys/values defined/used\n         * @return {?}\n         */\n        get: function () {\n            return this._inputMap;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BaseFxDirectiveAdapter.prototype, \"mqActivation\", {\n        /**\n         * @see BaseFxDirective._mqActivation\n         * @return {?}\n         */\n        get: function () {\n            return this._mqActivation;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Does this directive have 1 or more responsive keys defined\n     * Note: we exclude the 'baseKey' key (which is NOT considered responsive)\n     * @return {?}\n     */\n    BaseFxDirectiveAdapter.prototype.hasResponsiveAPI = function () {\n        return _super.prototype.hasResponsiveAPI.call(this, this._baseKey);\n    };\n    /**\n     * @see BaseFxDirective._queryInput\n     * @param {?} key\n     * @return {?}\n     */\n    BaseFxDirectiveAdapter.prototype.queryInput = function (key) {\n        return key ? this._queryInput(key) : undefined;\n    };\n    /**\n     *  Save the property value.\n     * @param {?=} key\n     * @param {?=} source\n     * @param {?=} cacheRaw\n     * @return {?}\n     */\n    BaseFxDirectiveAdapter.prototype.cacheInput = function (key, source, cacheRaw) {\n        if (cacheRaw === void 0) {\n            cacheRaw = false;\n        }\n        if (cacheRaw) {\n            this._cacheInputRaw(key, source);\n        }\n        else if (Array.isArray(source)) {\n            this._cacheInputArray(key, source);\n        }\n        else if (typeof source === 'object') {\n            this._cacheInputObject(key, source);\n        }\n        else if (typeof source === 'string') {\n            this._cacheInputString(key, source);\n        }\n        else {\n            throw new Error(\"Invalid class value '\" + key + \"' provided. Did you want to cache the raw value?\");\n        }\n    };\n    /**\n     * @see BaseFxDirective._listenForMediaQueryChanges\n     * @param {?} key\n     * @param {?} defaultValue\n     * @param {?} onMediaQueryChange\n     * @return {?}\n     */\n    BaseFxDirectiveAdapter.prototype.listenForMediaQueryChanges = function (key, defaultValue, onMediaQueryChange) {\n        return this._listenForMediaQueryChanges(key, defaultValue, onMediaQueryChange);\n    };\n    /**\n     * No implicit transforms of the source.\n     * Required when caching values expected later for KeyValueDiffers\n     * @param {?=} key\n     * @param {?=} source\n     * @return {?}\n     */\n    BaseFxDirectiveAdapter.prototype._cacheInputRaw = function (key, source) {\n        this._inputMap[key] = source;\n    };\n    /**\n     *  Save the property value for Array values.\n     * @param {?=} key\n     * @param {?=} source\n     * @return {?}\n     */\n    BaseFxDirectiveAdapter.prototype._cacheInputArray = function (key, source) {\n        if (key === void 0) {\n            key = '';\n        }\n        this._inputMap[key] = source.join(' ');\n    };\n    /**\n     *  Save the property value for key/value pair values.\n     * @param {?=} key\n     * @param {?=} source\n     * @return {?}\n     */\n    BaseFxDirectiveAdapter.prototype._cacheInputObject = function (key, source) {\n        if (key === void 0) {\n            key = '';\n        }\n        var /** @type {?} */ classes = [];\n        for (var /** @type {?} */ prop in source) {\n            if (!!source[prop]) {\n                classes.push(prop);\n            }\n        }\n        this._inputMap[key] = classes.join(' ');\n    };\n    /**\n     *  Save the property value for string values.\n     * @param {?=} key\n     * @param {?=} source\n     * @return {?}\n     */\n    BaseFxDirectiveAdapter.prototype._cacheInputString = function (key, source) {\n        if (key === void 0) {\n            key = '';\n        }\n        this._inputMap[key] = source;\n    };\n    return BaseFxDirectiveAdapter;\n}(BaseFxDirective));\n// @TODO - remove after updating to TS v2.4\n// tslint:disable:no-unused-variable\n/**\n *  Injection token unique to the flex-layout library.\n *  Use this token when build a custom provider (see below).\n */\nvar BREAKPOINTS = new InjectionToken('Token (@angular/flex-layout) Breakpoints');\n/**\n * Registry of 1..n MediaQuery breakpoint ranges\n * This is published as a provider and may be overriden from custom, application-specific ranges\n *\n */\nvar BreakPointRegistry = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} _registry\n     */\n    function BreakPointRegistry(_registry) {\n        this._registry = _registry;\n    }\n    Object.defineProperty(BreakPointRegistry.prototype, \"items\", {\n        /**\n         * Accessor to raw list\n         * @return {?}\n         */\n        get: function () {\n            return this._registry.slice();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BreakPointRegistry.prototype, \"sortedItems\", {\n        /**\n         * Accessor to sorted list used for registration with matchMedia API\n         *\n         * NOTE: During breakpoint registration, we want to register the overlaps FIRST\n         *       so the non-overlaps will trigger the MatchMedia:BehaviorSubject last!\n         *       And the largest, non-overlap, matching breakpoint should be the lastReplay value\n         * @return {?}\n         */\n        get: function () {\n            var /** @type {?} */ overlaps = this._registry.filter(function (it) { return it.overlapping === true; });\n            var /** @type {?} */ nonOverlaps = this._registry.filter(function (it) { return it.overlapping !== true; });\n            return overlaps.concat(nonOverlaps);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Search breakpoints by alias (e.g. gt-xs)\n     * @param {?} alias\n     * @return {?}\n     */\n    BreakPointRegistry.prototype.findByAlias = function (alias) {\n        return this._registry.find(function (bp) { return bp.alias == alias; }) || null;\n    };\n    /**\n     * @param {?} query\n     * @return {?}\n     */\n    BreakPointRegistry.prototype.findByQuery = function (query) {\n        return this._registry.find(function (bp) { return bp.mediaQuery == query; }) || null;\n    };\n    Object.defineProperty(BreakPointRegistry.prototype, \"overlappings\", {\n        /**\n         * Get all the breakpoints whose ranges could overlapping `normal` ranges;\n         * e.g. gt-sm overlaps md, lg, and xl\n         * @return {?}\n         */\n        get: function () {\n            return this._registry.filter(function (it) { return it.overlapping == true; });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BreakPointRegistry.prototype, \"aliases\", {\n        /**\n         * Get list of all registered (non-empty) breakpoint aliases\n         * @return {?}\n         */\n        get: function () {\n            return this._registry.map(function (it) { return it.alias; });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BreakPointRegistry.prototype, \"suffixes\", {\n        /**\n         * Aliases are mapped to properties using suffixes\n         * e.g.  'gt-sm' for property 'layout'  uses suffix 'GtSm'\n         * for property layoutGtSM.\n         * @return {?}\n         */\n        get: function () {\n            return this._registry.map(function (it) { return !!it.suffix ? it.suffix : ''; });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return BreakPointRegistry;\n}());\n/**\n * Class instances emitted [to observers] for each mql notification\n */\nvar MediaChange = /*@__PURE__*/ (function () {\n    /**\n     * @param {?=} matches\n     * @param {?=} mediaQuery\n     * @param {?=} mqAlias\n     * @param {?=} suffix\n     */\n    function MediaChange(matches, mediaQuery, mqAlias, suffix // e.g.   GtSM, Md, GtLg\n    ) {\n        if (matches === void 0) {\n            matches = false;\n        }\n        if (mediaQuery === void 0) {\n            mediaQuery = 'all';\n        }\n        if (mqAlias === void 0) {\n            mqAlias = '';\n        }\n        if (suffix === void 0) {\n            suffix = '';\n        } // e.g.   GtSM, Md, GtLg\n        this.matches = matches;\n        this.mediaQuery = mediaQuery;\n        this.mqAlias = mqAlias;\n        this.suffix = suffix; // e.g.   GtSM, Md, GtLg\n    }\n    /**\n     * @return {?}\n     */\n    MediaChange.prototype.clone = function () {\n        return new MediaChange(this.matches, this.mediaQuery, this.mqAlias, this.suffix);\n    };\n    return MediaChange;\n}());\n/**\n * MediaMonitor configures listeners to mediaQuery changes and publishes an Observable facade to\n * convert mediaQuery change callbacks to subscriber notifications. These notifications will be\n * performed within the ng Zone to trigger change detections and component updates.\n *\n * NOTE: both mediaQuery activations and de-activations are announced in notifications\n */\nvar MatchMedia = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} _zone\n     * @param {?} _document\n     */\n    function MatchMedia(_zone, _document) {\n        this._zone = _zone;\n        this._document = _document;\n        this._registry = new Map();\n        this._source = new BehaviorSubject(new MediaChange(true));\n        this._observable$ = this._source.asObservable();\n    }\n    /**\n     * For the specified mediaQuery?\n     * @param {?} mediaQuery\n     * @return {?}\n     */\n    MatchMedia.prototype.isActive = function (mediaQuery) {\n        var /** @type {?} */ mql = this._registry.get(mediaQuery);\n        return !!mql ? mql.matches : false;\n    };\n    /**\n     * External observers can watch for all (or a specific) mql changes.\n     * Typically used by the MediaQueryAdaptor; optionally available to components\n     * who wish to use the MediaMonitor as mediaMonitor$ observable service.\n     *\n     * NOTE: if a mediaQuery is not specified, then ALL mediaQuery activations will\n     *       be announced.\n     * @param {?=} mediaQuery\n     * @return {?}\n     */\n    MatchMedia.prototype.observe = function (mediaQuery) {\n        if (mediaQuery) {\n            this.registerQuery(mediaQuery);\n        }\n        return this._observable$.pipe(filter(function (change) {\n            return mediaQuery ? (change.mediaQuery === mediaQuery) : true;\n        }));\n    };\n    /**\n     * Based on the BreakPointRegistry provider, register internal listeners for each unique\n     * mediaQuery. Each listener emits specific MediaChange data to observers\n     * @param {?} mediaQuery\n     * @return {?}\n     */\n    MatchMedia.prototype.registerQuery = function (mediaQuery) {\n        var _this = this;\n        var /** @type {?} */ list = normalizeQuery(mediaQuery);\n        if (list.length > 0) {\n            prepareQueryCSS(list, this._document);\n            list.forEach(function (query) {\n                var /** @type {?} */ mql = _this._registry.get(query);\n                var /** @type {?} */ onMQLEvent = function (e) {\n                    _this._zone.run(function () {\n                        var /** @type {?} */ change = new MediaChange(e.matches, query);\n                        _this._source.next(change);\n                    });\n                };\n                if (!mql) {\n                    mql = _this._buildMQL(query);\n                    mql.addListener(onMQLEvent);\n                    _this._registry.set(query, mql);\n                }\n                if (mql.matches) {\n                    onMQLEvent(mql); // Announce activate range for initial subscribers\n                }\n            });\n        }\n    };\n    /**\n     * Call window.matchMedia() to build a MediaQueryList; which\n     * supports 0..n listeners for activation/deactivation\n     * @param {?} query\n     * @return {?}\n     */\n    MatchMedia.prototype._buildMQL = function (query) {\n        var /** @type {?} */ canListen = isBrowser() && !!((window)).matchMedia('all').addListener;\n        return canListen ? ((window)).matchMedia(query) : ({\n            matches: query === 'all' || query === '',\n            media: query,\n            addListener: function () {\n            },\n            removeListener: function () {\n            }\n        });\n    };\n    return MatchMedia;\n}());\n/**\n * Determine if SSR or Browser rendering.\n * @return {?}\n */\nfunction isBrowser() {\n    return ɵgetDOM().supportsDOMEvents();\n}\n/**\n * Private global registry for all dynamically-created, injected style tags\n * @see prepare(query)\n */\nvar ALL_STYLES = {};\n/**\n * For Webkit engines that only trigger the MediaQueryList Listener\n * when there is at least one CSS selector for the respective media query.\n *\n * @param {?} mediaQueries\n * @param {?} _document\n * @return {?}\n */\nfunction prepareQueryCSS(mediaQueries, _document) {\n    var /** @type {?} */ list = mediaQueries.filter(function (it) { return !ALL_STYLES[it]; });\n    if (list.length > 0) {\n        var /** @type {?} */ query = list.join(', ');\n        try {\n            var /** @type {?} */ styleEl_1 = ɵgetDOM().createElement('style');\n            ɵgetDOM().setAttribute(styleEl_1, 'type', 'text/css');\n            if (!styleEl_1['styleSheet']) {\n                var /** @type {?} */ cssText = \"/*\\n  @angular/flex-layout - workaround for possible browser quirk with mediaQuery listeners\\n  see http://bit.ly/2sd4HMP\\n*/\\n@media \" + query + \" {.fx-query-test{ }}\";\n                ɵgetDOM().appendChild(styleEl_1, ɵgetDOM().createTextNode(cssText));\n            }\n            ɵgetDOM().appendChild(_document.head, styleEl_1);\n            // Store in private global registry\n            list.forEach(function (mq) { return ALL_STYLES[mq] = styleEl_1; });\n        }\n        catch (e) {\n            console.error(e);\n        }\n    }\n}\n/**\n * Always convert to unique list of queries; for iteration in ::registerQuery()\n * @param {?} mediaQuery\n * @return {?}\n */\nfunction normalizeQuery(mediaQuery) {\n    return (typeof mediaQuery === 'undefined') ? [] :\n        (typeof mediaQuery === 'string') ? [mediaQuery] : unique(/** @type {?} */ (mediaQuery));\n}\n/**\n * Filter duplicate mediaQueries in the list\n * @param {?} list\n * @return {?}\n */\nfunction unique(list) {\n    var /** @type {?} */ seen = {};\n    return list.filter(function (item) {\n        return seen.hasOwnProperty(item) ? false : (seen[item] = true);\n    });\n}\n/**\n * For the specified MediaChange, make sure it contains the breakpoint alias\n * and suffix (if available).\n * @param {?} dest\n * @param {?} source\n * @return {?}\n */\nfunction mergeAlias(dest, source) {\n    return extendObject(dest, source ? {\n        mqAlias: source.alias,\n        suffix: source.suffix\n    } : {});\n}\n/**\n * MediaMonitor uses the MatchMedia service to observe mediaQuery changes (both activations and\n * deactivations). These changes are are published as MediaChange notifications.\n *\n * Note: all notifications will be performed within the\n * ng Zone to trigger change detections and component updates.\n *\n * It is the MediaMonitor that:\n *  - auto registers all known breakpoints\n *  - injects alias information into each raw MediaChange event\n *  - provides accessor to the currently active BreakPoint\n *  - publish list of overlapping BreakPoint(s); used by ResponsiveActivation\n */\nvar MediaMonitor = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} _breakpoints\n     * @param {?} _matchMedia\n     */\n    function MediaMonitor(_breakpoints, _matchMedia) {\n        this._breakpoints = _breakpoints;\n        this._matchMedia = _matchMedia;\n        this._registerBreakpoints();\n    }\n    Object.defineProperty(MediaMonitor.prototype, \"breakpoints\", {\n        /**\n         * Read-only accessor to the list of breakpoints configured in the BreakPointRegistry provider\n         * @return {?}\n         */\n        get: function () {\n            return this._breakpoints.items.slice();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MediaMonitor.prototype, \"activeOverlaps\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            var _this = this;\n            var /** @type {?} */ items = this._breakpoints.overlappings.reverse();\n            return items.filter(function (bp) {\n                return _this._matchMedia.isActive(bp.mediaQuery);\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MediaMonitor.prototype, \"active\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            var _this = this;\n            var /** @type {?} */ found = null, /** @type {?} */ items = this.breakpoints.reverse();\n            items.forEach(function (bp) {\n                if (bp.alias !== '') {\n                    if (!found && _this._matchMedia.isActive(bp.mediaQuery)) {\n                        found = bp;\n                    }\n                }\n            });\n            var /** @type {?} */ first = this.breakpoints[0];\n            return found || (this._matchMedia.isActive(first.mediaQuery) ? first : null);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * For the specified mediaQuery alias, is the mediaQuery range active?\n     * @param {?} alias\n     * @return {?}\n     */\n    MediaMonitor.prototype.isActive = function (alias) {\n        var /** @type {?} */ bp = this._breakpoints.findByAlias(alias) || this._breakpoints.findByQuery(alias);\n        return this._matchMedia.isActive(bp ? bp.mediaQuery : alias);\n    };\n    /**\n     * External observers can watch for all (or a specific) mql changes.\n     * If specific breakpoint is observed, only return *activated* events\n     * otherwise return all events for BOTH activated + deactivated changes.\n     * @param {?=} alias\n     * @return {?}\n     */\n    MediaMonitor.prototype.observe = function (alias) {\n        var /** @type {?} */ bp = this._breakpoints.findByAlias(alias || '') ||\n            this._breakpoints.findByQuery(alias || '');\n        var /** @type {?} */ hasAlias = function (change) { return (bp ? change.mqAlias !== '' : true); };\n        // Note: the raw MediaChange events [from MatchMedia] do not contain important alias information\n        var /** @type {?} */ media$ = this._matchMedia.observe(bp ? bp.mediaQuery : alias);\n        return media$.pipe(map(function (change) { return mergeAlias(change, bp); }), filter(hasAlias));\n    };\n    /**\n     * Immediate calls to matchMedia() to establish listeners\n     * and prepare for immediate subscription notifications\n     * @return {?}\n     */\n    MediaMonitor.prototype._registerBreakpoints = function () {\n        var /** @type {?} */ queries = this._breakpoints.sortedItems.map(function (bp) { return bp.mediaQuery; });\n        this._matchMedia.registerQuery(queries);\n    };\n    return MediaMonitor;\n}());\n/**\n * 'layout' flexbox styling directive\n * Defines the positioning flow direction for the child elements: row or column\n * Optional values: column or row (default)\n * @see https://css-tricks.com/almanac/properties/f/flex-direction/\n *\n */\nvar LayoutDirective = /*@__PURE__*/ (function (_super) {\n    __extends(LayoutDirective, _super);\n    /**\n     *\n     * @param {?} monitor\n     * @param {?} elRef\n     * @param {?} renderer\n     */\n    function LayoutDirective(monitor, elRef, renderer) {\n        var _this = _super.call(this, monitor, elRef, renderer) || this;\n        _this._announcer = new ReplaySubject(1);\n        _this.layout$ = _this._announcer.asObservable();\n        return _this;\n    }\n    Object.defineProperty(LayoutDirective.prototype, \"layout\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('layout', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutDirective.prototype, \"layoutXs\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('layoutXs', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutDirective.prototype, \"layoutSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('layoutSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutDirective.prototype, \"layoutMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('layoutMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutDirective.prototype, \"layoutLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('layoutLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutDirective.prototype, \"layoutXl\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('layoutXl', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutDirective.prototype, \"layoutGtXs\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('layoutGtXs', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutDirective.prototype, \"layoutGtSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('layoutGtSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutDirective.prototype, \"layoutGtMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('layoutGtMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutDirective.prototype, \"layoutGtLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('layoutGtLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutDirective.prototype, \"layoutLtSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('layoutLtSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutDirective.prototype, \"layoutLtMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('layoutLtMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutDirective.prototype, \"layoutLtLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('layoutLtLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutDirective.prototype, \"layoutLtXl\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('layoutLtXl', val); },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * On changes to any \\@Input properties...\n     * Default to use the non-responsive Input value ('fxLayout')\n     * Then conditionally override with the mq-activated Input's current value\n     * @param {?} changes\n     * @return {?}\n     */\n    LayoutDirective.prototype.ngOnChanges = function (changes) {\n        if (changes['layout'] != null || this._mqActivation) {\n            this._updateWithDirection();\n        }\n    };\n    /**\n     * After the initial onChanges, build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     * @return {?}\n     */\n    LayoutDirective.prototype.ngOnInit = function () {\n        var _this = this;\n        _super.prototype.ngOnInit.call(this);\n        this._listenForMediaQueryChanges('layout', 'row', function (changes) {\n            _this._updateWithDirection(changes.value);\n        });\n        this._updateWithDirection();\n    };\n    /**\n     * Validate the direction value and then update the host's inline flexbox styles\n     * @param {?=} value\n     * @return {?}\n     */\n    LayoutDirective.prototype._updateWithDirection = function (value) {\n        value = value || this._queryInput('layout') || 'row';\n        if (this._mqActivation) {\n            value = this._mqActivation.activatedInput;\n        }\n        // Update styles and announce to subscribers the *new* direction\n        var /** @type {?} */ css = buildLayoutCSS(!!value ? value : '');\n        this._applyStyleToElement(css);\n        this._announcer.next(css['flex-direction']);\n    };\n    return LayoutDirective;\n}(BaseFxDirective));\n/**\n * 'layout-align' flexbox styling directive\n *  Defines positioning of child elements along main and cross axis in a layout container\n *  Optional values: {main-axis} values or {main-axis cross-axis} value pairs\n *\n *  \\@see https://css-tricks.com/almanac/properties/j/justify-content/\n *  \\@see https://css-tricks.com/almanac/properties/a/align-items/\n *  \\@see https://css-tricks.com/almanac/properties/a/align-content/\n */\nvar LayoutAlignDirective = /*@__PURE__*/ (function (_super) {\n    __extends(LayoutAlignDirective, _super);\n    /**\n     * @param {?} monitor\n     * @param {?} elRef\n     * @param {?} renderer\n     * @param {?} container\n     */\n    function LayoutAlignDirective(monitor, elRef, renderer, container) {\n        var _this = _super.call(this, monitor, elRef, renderer) || this;\n        _this._layout = 'row'; // default flex-direction\n        if (container) {\n            _this._layoutWatcher = container.layout$.subscribe(_this._onLayoutChange.bind(_this));\n        }\n        return _this;\n    }\n    Object.defineProperty(LayoutAlignDirective.prototype, \"align\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('align', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutAlignDirective.prototype, \"alignXs\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('alignXs', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutAlignDirective.prototype, \"alignSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('alignSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutAlignDirective.prototype, \"alignMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('alignMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutAlignDirective.prototype, \"alignLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('alignLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutAlignDirective.prototype, \"alignXl\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('alignXl', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutAlignDirective.prototype, \"alignGtXs\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('alignGtXs', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutAlignDirective.prototype, \"alignGtSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('alignGtSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutAlignDirective.prototype, \"alignGtMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('alignGtMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutAlignDirective.prototype, \"alignGtLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('alignGtLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutAlignDirective.prototype, \"alignLtSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('alignLtSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutAlignDirective.prototype, \"alignLtMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('alignLtMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutAlignDirective.prototype, \"alignLtLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('alignLtLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutAlignDirective.prototype, \"alignLtXl\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('alignLtXl', val); },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    LayoutAlignDirective.prototype.ngOnChanges = function (changes) {\n        if (changes['align'] != null || this._mqActivation) {\n            this._updateWithValue();\n        }\n    };\n    /**\n     * After the initial onChanges, build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     * @return {?}\n     */\n    LayoutAlignDirective.prototype.ngOnInit = function () {\n        var _this = this;\n        _super.prototype.ngOnInit.call(this);\n        this._listenForMediaQueryChanges('align', 'start stretch', function (changes) {\n            _this._updateWithValue(changes.value);\n        });\n        this._updateWithValue();\n    };\n    /**\n     * @return {?}\n     */\n    LayoutAlignDirective.prototype.ngOnDestroy = function () {\n        _super.prototype.ngOnDestroy.call(this);\n        if (this._layoutWatcher) {\n            this._layoutWatcher.unsubscribe();\n        }\n    };\n    /**\n     *\n     * @param {?=} value\n     * @return {?}\n     */\n    LayoutAlignDirective.prototype._updateWithValue = function (value) {\n        value = value || this._queryInput('align') || 'start stretch';\n        if (this._mqActivation) {\n            value = this._mqActivation.activatedInput;\n        }\n        this._applyStyleToElement(this._buildCSS(value));\n        this._allowStretching(value, !this._layout ? 'row' : this._layout);\n    };\n    /**\n     * Cache the parent container 'flex-direction' and update the 'flex' styles\n     * @param {?} direction\n     * @return {?}\n     */\n    LayoutAlignDirective.prototype._onLayoutChange = function (direction) {\n        var _this = this;\n        this._layout = (direction || '').toLowerCase();\n        if (!LAYOUT_VALUES.find(function (x) { return x === _this._layout; })) {\n            this._layout = 'row';\n        }\n        var /** @type {?} */ value = this._queryInput('align') || 'start stretch';\n        if (this._mqActivation) {\n            value = this._mqActivation.activatedInput;\n        }\n        this._allowStretching(value, this._layout || 'row');\n    };\n    /**\n     * @param {?} align\n     * @return {?}\n     */\n    LayoutAlignDirective.prototype._buildCSS = function (align) {\n        var /** @type {?} */ css = {}, _a = align.split(' '), main_axis = _a[0], cross_axis = _a[1]; // tslint:disable-line:variable-name\n        // Main axis\n        switch (main_axis) {\n            case 'center':\n                css['justify-content'] = 'center';\n                break;\n            case 'space-around':\n                css['justify-content'] = 'space-around';\n                break;\n            case 'space-between':\n                css['justify-content'] = 'space-between';\n                break;\n            case 'space-evenly':\n                css['justify-content'] = 'space-evenly';\n                break;\n            case 'end':\n            case 'flex-end':\n                css['justify-content'] = 'flex-end';\n                break;\n            case 'start':\n            case 'flex-start':\n            default:\n                css['justify-content'] = 'flex-start'; // default main axis\n                break;\n        }\n        // Cross-axis\n        switch (cross_axis) {\n            case 'start':\n            case 'flex-start':\n                css['align-items'] = css['align-content'] = 'flex-start';\n                break;\n            case 'baseline':\n                css['align-items'] = 'baseline';\n                break;\n            case 'center':\n                css['align-items'] = css['align-content'] = 'center';\n                break;\n            case 'end':\n            case 'flex-end':\n                css['align-items'] = css['align-content'] = 'flex-end';\n                break;\n            case 'stretch':\n            default:// 'stretch'\n                css['align-items'] = css['align-content'] = 'stretch'; // default cross axis\n                break;\n        }\n        return extendObject(css, {\n            'display': 'flex',\n            'flex-direction': this._layout || 'row',\n            'box-sizing': 'border-box'\n        });\n    };\n    /**\n     * Update container element to 'stretch' as needed...\n     * NOTE: this is only done if the crossAxis is explicitly set to 'stretch'\n     * @param {?} align\n     * @param {?} layout\n     * @return {?}\n     */\n    LayoutAlignDirective.prototype._allowStretching = function (align, layout) {\n        var _a = align.split(' '), cross_axis = _a[1]; // tslint:disable-line:variable-name\n        if (cross_axis == 'stretch') {\n            // Use `null` values to remove style\n            this._applyStyleToElement({\n                'box-sizing': 'border-box',\n                'max-width': !isFlowHorizontal(layout) ? '100%' : null,\n                'max-height': isFlowHorizontal(layout) ? '100%' : null\n            });\n        }\n    };\n    return LayoutAlignDirective;\n}(BaseFxDirective));\n/**\n * 'layout-padding' styling directive\n *  Defines padding of child elements in a layout container\n */\nvar LayoutGapDirective = /*@__PURE__*/ (function (_super) {\n    __extends(LayoutGapDirective, _super);\n    /**\n     * @param {?} monitor\n     * @param {?} elRef\n     * @param {?} renderer\n     * @param {?} container\n     * @param {?} _zone\n     */\n    function LayoutGapDirective(monitor, elRef, renderer, container, _zone) {\n        var _this = _super.call(this, monitor, elRef, renderer) || this;\n        _this._zone = _zone;\n        _this._layout = 'row'; // default flex-direction\n        if (container) {\n            _this._layoutWatcher = container.layout$.subscribe(_this._onLayoutChange.bind(_this));\n        }\n        return _this;\n    }\n    Object.defineProperty(LayoutGapDirective.prototype, \"gap\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('gap', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutGapDirective.prototype, \"gapXs\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('gapXs', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutGapDirective.prototype, \"gapSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('gapSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutGapDirective.prototype, \"gapMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('gapMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutGapDirective.prototype, \"gapLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('gapLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutGapDirective.prototype, \"gapXl\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('gapXl', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutGapDirective.prototype, \"gapGtXs\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('gapGtXs', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutGapDirective.prototype, \"gapGtSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('gapGtSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutGapDirective.prototype, \"gapGtMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('gapGtMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutGapDirective.prototype, \"gapGtLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('gapGtLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutGapDirective.prototype, \"gapLtSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('gapLtSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutGapDirective.prototype, \"gapLtMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('gapLtMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutGapDirective.prototype, \"gapLtLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('gapLtLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutGapDirective.prototype, \"gapLtXl\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('gapLtXl', val); },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    LayoutGapDirective.prototype.ngOnChanges = function (changes) {\n        if (changes['gap'] != null || this._mqActivation) {\n            this._updateWithValue();\n        }\n    };\n    /**\n     * After the initial onChanges, build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     * @return {?}\n     */\n    LayoutGapDirective.prototype.ngAfterContentInit = function () {\n        var _this = this;\n        this._watchContentChanges();\n        this._listenForMediaQueryChanges('gap', '0', function (changes) {\n            _this._updateWithValue(changes.value);\n        });\n        this._updateWithValue();\n    };\n    /**\n     * @return {?}\n     */\n    LayoutGapDirective.prototype.ngOnDestroy = function () {\n        _super.prototype.ngOnDestroy.call(this);\n        if (this._layoutWatcher) {\n            this._layoutWatcher.unsubscribe();\n        }\n        if (this._observer) {\n            this._observer.disconnect();\n        }\n    };\n    /**\n     * Watch for child nodes to be added... and apply the layout gap styles to each.\n     * NOTE: this does NOT! differentiate between viewChildren and contentChildren\n     * @return {?}\n     */\n    LayoutGapDirective.prototype._watchContentChanges = function () {\n        var _this = this;\n        this._zone.runOutsideAngular(function () {\n            if (typeof MutationObserver !== 'undefined') {\n                _this._observer = new MutationObserver(function (mutations) {\n                    var /** @type {?} */ validatedChanges = function (it) {\n                        return (it.addedNodes && it.addedNodes.length > 0) ||\n                            (it.removedNodes && it.removedNodes.length > 0);\n                    };\n                    // update gap styles only for child 'added' or 'removed' events\n                    if (mutations.some(validatedChanges)) {\n                        _this._updateWithValue();\n                    }\n                });\n                _this._observer.observe(_this.nativeElement, { childList: true });\n            }\n        });\n    };\n    /**\n     * Cache the parent container 'flex-direction' and update the 'margin' styles\n     * @param {?} direction\n     * @return {?}\n     */\n    LayoutGapDirective.prototype._onLayoutChange = function (direction) {\n        var _this = this;\n        this._layout = (direction || '').toLowerCase();\n        if (!LAYOUT_VALUES.find(function (x) { return x === _this._layout; })) {\n            this._layout = 'row';\n        }\n        this._updateWithValue();\n    };\n    /**\n     *\n     * @param {?=} value\n     * @return {?}\n     */\n    LayoutGapDirective.prototype._updateWithValue = function (value) {\n        var _this = this;\n        value = value || this._queryInput('gap') || '0';\n        if (this._mqActivation) {\n            value = this._mqActivation.activatedInput;\n        }\n        // Gather all non-hidden Element nodes\n        var /** @type {?} */ items = this.childrenNodes\n            .filter(function (el) { return el.nodeType === 1 && _this._getDisplayStyle(el) != 'none'; });\n        var /** @type {?} */ numItems = items.length;\n        if (numItems > 0) {\n            var /** @type {?} */ lastItem = items[numItems - 1];\n            // For each `element` children EXCEPT the last,\n            // set the margin right/bottom styles...\n            items = items.filter(function (_, j) { return j < numItems - 1; });\n            this._applyStyleToElements(this._buildCSS(value), items);\n            // Clear all gaps for all visible elements\n            this._applyStyleToElements(this._buildCSS(), [lastItem]);\n        }\n    };\n    /**\n     * Prepare margin CSS, remove any previous explicitly\n     * assigned margin assignments\n     * @param {?=} value\n     * @return {?}\n     */\n    LayoutGapDirective.prototype._buildCSS = function (value) {\n        if (value === void 0) {\n            value = null;\n        }\n        var /** @type {?} */ key, /** @type {?} */ margins = {\n            'margin-left': null,\n            'margin-right': null,\n            'margin-top': null,\n            'margin-bottom': null\n        };\n        switch (this._layout) {\n            case 'column':\n            case 'column-reverse':\n                key = 'margin-bottom';\n                break;\n            case 'row':\n            case 'row-reverse':\n            default:\n                key = 'margin-right';\n                break;\n        }\n        margins[key] = value;\n        return margins;\n    };\n    return LayoutGapDirective;\n}(BaseFxDirective));\n/**\n * @deprecated\n * This functionality is now part of the `fxLayout` API\n *\n * 'layout-wrap' flexbox styling directive\n * Defines wrapping of child elements in layout container\n * Optional values: reverse, wrap-reverse, none, nowrap, wrap (default)]\n *\n *\n * @see https://css-tricks.com/almanac/properties/f/flex-wrap/\n */\nvar LayoutWrapDirective = /*@__PURE__*/ (function (_super) {\n    __extends(LayoutWrapDirective, _super);\n    /**\n     * @param {?} monitor\n     * @param {?} elRef\n     * @param {?} renderer\n     * @param {?} container\n     */\n    function LayoutWrapDirective(monitor, elRef, renderer, container) {\n        var _this = _super.call(this, monitor, elRef, renderer) || this;\n        _this._layout = 'row'; // default flex-direction\n        if (container) {\n            _this._layoutWatcher = container.layout$.subscribe(_this._onLayoutChange.bind(_this));\n        }\n        return _this;\n    }\n    Object.defineProperty(LayoutWrapDirective.prototype, \"wrap\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('wrap', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutWrapDirective.prototype, \"wrapXs\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('wrapXs', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutWrapDirective.prototype, \"wrapSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('wrapSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutWrapDirective.prototype, \"wrapMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('wrapMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutWrapDirective.prototype, \"wrapLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('wrapLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutWrapDirective.prototype, \"wrapXl\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('wrapXl', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutWrapDirective.prototype, \"wrapGtXs\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('wrapGtXs', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutWrapDirective.prototype, \"wrapGtSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('wrapGtSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutWrapDirective.prototype, \"wrapGtMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('wrapGtMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutWrapDirective.prototype, \"wrapGtLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('wrapGtLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutWrapDirective.prototype, \"wrapLtSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('wrapLtSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutWrapDirective.prototype, \"wrapLtMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('wrapLtMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutWrapDirective.prototype, \"wrapLtLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('wrapLtLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutWrapDirective.prototype, \"wrapLtXl\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('wrapLtXl', val); },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    LayoutWrapDirective.prototype.ngOnChanges = function (changes) {\n        if (changes['wrap'] != null || this._mqActivation) {\n            this._updateWithValue();\n        }\n    };\n    /**\n     * After the initial onChanges, build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     * @return {?}\n     */\n    LayoutWrapDirective.prototype.ngOnInit = function () {\n        var _this = this;\n        _super.prototype.ngOnInit.call(this);\n        this._listenForMediaQueryChanges('wrap', 'wrap', function (changes) {\n            _this._updateWithValue(changes.value);\n        });\n        this._updateWithValue();\n    };\n    /**\n     * @return {?}\n     */\n    LayoutWrapDirective.prototype.ngOnDestroy = function () {\n        _super.prototype.ngOnDestroy.call(this);\n        if (this._layoutWatcher) {\n            this._layoutWatcher.unsubscribe();\n        }\n    };\n    /**\n     * Cache the parent container 'flex-direction' and update the 'flex' styles\n     * @param {?} direction\n     * @return {?}\n     */\n    LayoutWrapDirective.prototype._onLayoutChange = function (direction) {\n        var _this = this;\n        this._layout = (direction || '').toLowerCase().replace('-reverse', '');\n        if (!LAYOUT_VALUES.find(function (x) { return x === _this._layout; })) {\n            this._layout = 'row';\n        }\n        this._updateWithValue();\n    };\n    /**\n     * @param {?=} value\n     * @return {?}\n     */\n    LayoutWrapDirective.prototype._updateWithValue = function (value) {\n        value = value || this._queryInput('wrap');\n        if (this._mqActivation) {\n            value = this._mqActivation.activatedInput;\n        }\n        value = validateWrapValue(value || 'wrap');\n        this._applyStyleToElement(this._buildCSS(value));\n    };\n    /**\n     * Build the CSS that should be assigned to the element instance\n     * @param {?} value\n     * @return {?}\n     */\n    LayoutWrapDirective.prototype._buildCSS = function (value) {\n        return {\n            'display': 'flex',\n            'flex-wrap': value,\n            'flex-direction': this.flowDirection\n        };\n    };\n    Object.defineProperty(LayoutWrapDirective.prototype, \"flowDirection\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            var _this = this;\n            var /** @type {?} */ computeFlowDirection = function () { return _this._getFlowDirection(_this.nativeElement); };\n            return this._layoutWatcher ? this._layout : computeFlowDirection();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return LayoutWrapDirective;\n}(BaseFxDirective));\n/**\n * The flex API permits 3 or 1 parts of the value:\n *    - `flex-grow flex-shrink flex-basis`, or\n *    - `flex-basis`\n * @param {?} basis\n * @param {?=} grow\n * @param {?=} shrink\n * @return {?}\n */\nfunction validateBasis(basis, grow, shrink) {\n    if (grow === void 0) {\n        grow = '1';\n    }\n    if (shrink === void 0) {\n        shrink = '1';\n    }\n    var /** @type {?} */ parts = [grow, shrink, basis];\n    var /** @type {?} */ j = basis.indexOf('calc');\n    if (j > 0) {\n        parts[2] = _validateCalcValue(basis.substring(j).trim());\n        var /** @type {?} */ matches = basis.substr(0, j).trim().split(' ');\n        if (matches.length == 2) {\n            parts[0] = matches[0];\n            parts[1] = matches[1];\n        }\n    }\n    else if (j == 0) {\n        parts[2] = _validateCalcValue(basis.trim());\n    }\n    else {\n        var /** @type {?} */ matches = basis.split(' ');\n        parts = (matches.length === 3) ? matches : [\n            grow, shrink, basis\n        ];\n    }\n    return parts;\n}\n/**\n * Calc expressions require whitespace before & after any expression operators\n * This is a simple, crude whitespace padding solution.\n *   - '3 3 calc(15em + 20px)'\n *   - calc(100% / 7 * 2)\n *   - 'calc(15em + 20px)'\n *   - 'calc(15em+20px)'\n *   - '37px'\n *   = '43%'\n * @param {?} calc\n * @return {?}\n */\nfunction _validateCalcValue(calc) {\n    return calc.replace(/[\\s]/g, '').replace(/[\\/\\*\\+\\-]/g, ' $& ');\n}\n/**\n * Directive to control the size of a flex item using flex-basis, flex-grow, and flex-shrink.\n * Corresponds to the css `flex` shorthand property.\n *\n * @see https://css-tricks.com/snippets/css/a-guide-to-flexbox/\n */\nvar FlexDirective = /*@__PURE__*/ (function (_super) {\n    __extends(FlexDirective, _super);\n    /**\n     * @param {?} monitor\n     * @param {?} elRef\n     * @param {?} renderer\n     * @param {?} _container\n     * @param {?} _wrap\n     */\n    function FlexDirective(monitor, elRef, renderer, _container, _wrap) {\n        var _this = _super.call(this, monitor, elRef, renderer) || this;\n        _this._container = _container;\n        _this._wrap = _wrap;\n        _this._cacheInput('flex', '');\n        _this._cacheInput('shrink', 1);\n        _this._cacheInput('grow', 1);\n        if (_container) {\n            // If this flex item is inside of a flex container marked with\n            // Subscribe to layout immediate parent direction changes\n            _this._layoutWatcher = _container.layout$.subscribe(function (direction) {\n                // `direction` === null if parent container does not have a `fxLayout`\n                _this._onLayoutChange(direction);\n            });\n        }\n        return _this;\n    }\n    Object.defineProperty(FlexDirective.prototype, \"shrink\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('shrink', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexDirective.prototype, \"grow\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('grow', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexDirective.prototype, \"flex\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('flex', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexDirective.prototype, \"flexXs\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('flexXs', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexDirective.prototype, \"flexSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('flexSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexDirective.prototype, \"flexMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('flexMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexDirective.prototype, \"flexLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('flexLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexDirective.prototype, \"flexXl\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('flexXl', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexDirective.prototype, \"flexGtXs\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('flexGtXs', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexDirective.prototype, \"flexGtSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('flexGtSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexDirective.prototype, \"flexGtMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('flexGtMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexDirective.prototype, \"flexGtLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('flexGtLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexDirective.prototype, \"flexLtSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('flexLtSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexDirective.prototype, \"flexLtMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('flexLtMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexDirective.prototype, \"flexLtLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('flexLtLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexDirective.prototype, \"flexLtXl\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('flexLtXl', val); },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * For \\@Input changes on the current mq activation property, see onMediaQueryChanges()\n     * @param {?} changes\n     * @return {?}\n     */\n    FlexDirective.prototype.ngOnChanges = function (changes) {\n        if (changes['flex'] != null || this._mqActivation) {\n            this._updateStyle();\n        }\n    };\n    /**\n     * After the initial onChanges, build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     * @return {?}\n     */\n    FlexDirective.prototype.ngOnInit = function () {\n        var _this = this;\n        _super.prototype.ngOnInit.call(this);\n        this._listenForMediaQueryChanges('flex', '', function (changes) {\n            _this._updateStyle(changes.value);\n        });\n        this._updateStyle();\n    };\n    /**\n     * @return {?}\n     */\n    FlexDirective.prototype.ngOnDestroy = function () {\n        _super.prototype.ngOnDestroy.call(this);\n        if (this._layoutWatcher) {\n            this._layoutWatcher.unsubscribe();\n        }\n    };\n    /**\n     * Caches the parent container's 'flex-direction' and updates the element's style.\n     * Used as a handler for layout change events from the parent flex container.\n     * @param {?=} direction\n     * @return {?}\n     */\n    FlexDirective.prototype._onLayoutChange = function (direction) {\n        this._layout = direction || this._layout || 'row';\n        this._updateStyle();\n    };\n    /**\n     * @param {?=} value\n     * @return {?}\n     */\n    FlexDirective.prototype._updateStyle = function (value) {\n        var /** @type {?} */ flexBasis = value || this._queryInput('flex') || '';\n        if (this._mqActivation) {\n            flexBasis = this._mqActivation.activatedInput;\n        }\n        var /** @type {?} */ basis = String(flexBasis).replace(';', '');\n        var /** @type {?} */ parts = validateBasis(basis, this._queryInput('grow'), this._queryInput('shrink'));\n        this._applyStyleToElement(this._validateValue.apply(this, parts));\n    };\n    /**\n     * Validate the value to be one of the acceptable value options\n     * Use default fallback of 'row'\n     * @param {?} grow\n     * @param {?} shrink\n     * @param {?} basis\n     * @return {?}\n     */\n    FlexDirective.prototype._validateValue = function (grow, shrink, basis) {\n        // The flex-direction of this element's flex container. Defaults to 'row'.\n        var /** @type {?} */ layout = this._getFlowDirection(this.parentElement, true);\n        var /** @type {?} */ direction = (layout.indexOf('column') > -1) ? 'column' : 'row';\n        var /** @type {?} */ css, /** @type {?} */ isValue;\n        grow = (grow == '0') ? 0 : grow;\n        shrink = (shrink == '0') ? 0 : shrink;\n        // flex-basis allows you to specify the initial/starting main-axis size of the element,\n        // before anything else is computed. It can either be a percentage or an absolute value.\n        // It is, however, not the breaking point for flex-grow/shrink properties\n        //\n        // flex-grow can be seen as this:\n        //   0: Do not stretch. Either size to element's content width, or obey 'flex-basis'.\n        //   1: (Default value). Stretch; will be the same size to all other flex items on\n        //       the same row since they have a default value of 1.\n        //   ≥2 (integer n): Stretch. Will be n times the size of other elements\n        //      with 'flex-grow: 1' on the same row.\n        // Use `null` to clear existing styles.\n        var /** @type {?} */ clearStyles = {\n            'max-width': null,\n            'max-height': null,\n            'min-width': null,\n            'min-height': null\n        };\n        switch (basis || '') {\n            case '':\n                css = extendObject(clearStyles, { 'flex': grow + \" \" + shrink + \" 0.000000001px\" });\n                break;\n            case 'initial': // default\n            case 'nogrow':\n                grow = 0;\n                css = extendObject(clearStyles, { 'flex': '0 1 auto' });\n                break;\n            case 'grow':\n                css = extendObject(clearStyles, { 'flex': '1 1 100%' });\n                break;\n            case 'noshrink':\n                shrink = 0;\n                css = extendObject(clearStyles, { 'flex': '1 0 auto' });\n                break;\n            case 'auto':\n                css = extendObject(clearStyles, { 'flex': grow + \" \" + shrink + \" auto\" });\n                break;\n            case 'none':\n                grow = 0;\n                shrink = 0;\n                css = extendObject(clearStyles, { 'flex': '0 0 auto' });\n                break;\n            default:\n                var /** @type {?} */ hasCalc = String(basis).indexOf('calc') > -1;\n                var /** @type {?} */ isPercent = String(basis).indexOf('%') > -1 && !hasCalc;\n                isValue = hasCalc ||\n                    String(basis).indexOf('px') > -1 ||\n                    String(basis).indexOf('em') > -1 ||\n                    String(basis).indexOf('vw') > -1 ||\n                    String(basis).indexOf('vh') > -1;\n                // Defaults to percentage sizing unless `px` is explicitly set\n                if (!isValue && !isPercent && !isNaN(/** @type {?} */ (basis))) {\n                    basis = basis + '%';\n                }\n                if (basis === '0px') {\n                    basis = '0%';\n                }\n                // Set max-width = basis if using layout-wrap\n                // tslint:disable-next-line:max-line-length\n                // @see https://github.com/philipwalton/flexbugs#11-min-and-max-size-declarations-are-ignored-when-wrapping-flex-items\n                css = extendObject(clearStyles, {\n                    'flex-grow': \"\" + grow,\n                    'flex-shrink': \"\" + shrink,\n                    'flex-basis': (isValue || this._wrap) ? \"\" + basis : '100%'\n                });\n                break;\n        }\n        var /** @type {?} */ max = isFlowHorizontal(direction) ? 'max-width' : 'max-height';\n        var /** @type {?} */ min = isFlowHorizontal(direction) ? 'min-width' : 'min-height';\n        var /** @type {?} */ usingCalc = (String(basis).indexOf('calc') > -1) || (basis == 'auto');\n        var /** @type {?} */ isPx = String(basis).indexOf('px') > -1 || usingCalc;\n        // make box inflexible when shrink and grow are both zero\n        // should not set a min when the grow is zero\n        // should not set a max when the shrink is zero\n        var /** @type {?} */ isFixed = !grow && !shrink;\n        css[min] = (basis == '0%') ? 0 : isFixed || (isPx && grow) ? basis : null;\n        css[max] = (basis == '0%') ? 0 : isFixed || (!usingCalc && shrink) ? basis : null;\n        return extendObject(css, { 'box-sizing': 'border-box' });\n    };\n    return FlexDirective;\n}(BaseFxDirective));\n/**\n * 'flex-align' flexbox styling directive\n * Allows element-specific overrides for cross-axis alignments in a layout container\n * @see https://css-tricks.com/almanac/properties/a/align-self/\n */\nvar FlexAlignDirective = /*@__PURE__*/ (function (_super) {\n    __extends(FlexAlignDirective, _super);\n    /**\n     * @param {?} monitor\n     * @param {?} elRef\n     * @param {?} renderer\n     */\n    function FlexAlignDirective(monitor, elRef, renderer) {\n        return _super.call(this, monitor, elRef, renderer) || this;\n    }\n    Object.defineProperty(FlexAlignDirective.prototype, \"align\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('align', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexAlignDirective.prototype, \"alignXs\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('alignXs', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexAlignDirective.prototype, \"alignSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('alignSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexAlignDirective.prototype, \"alignMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('alignMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexAlignDirective.prototype, \"alignLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('alignLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexAlignDirective.prototype, \"alignXl\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('alignXl', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexAlignDirective.prototype, \"alignLtSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('alignLtSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexAlignDirective.prototype, \"alignLtMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('alignLtMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexAlignDirective.prototype, \"alignLtLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('alignLtLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexAlignDirective.prototype, \"alignLtXl\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('alignLtXl', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexAlignDirective.prototype, \"alignGtXs\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('alignGtXs', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexAlignDirective.prototype, \"alignGtSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('alignGtSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexAlignDirective.prototype, \"alignGtMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('alignGtMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexAlignDirective.prototype, \"alignGtLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('alignGtLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * For \\@Input changes on the current mq activation property, see onMediaQueryChanges()\n     * @param {?} changes\n     * @return {?}\n     */\n    FlexAlignDirective.prototype.ngOnChanges = function (changes) {\n        if (changes['align'] != null || this._mqActivation) {\n            this._updateWithValue();\n        }\n    };\n    /**\n     * After the initial onChanges, build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     * @return {?}\n     */\n    FlexAlignDirective.prototype.ngOnInit = function () {\n        var _this = this;\n        _super.prototype.ngOnInit.call(this);\n        this._listenForMediaQueryChanges('align', 'stretch', function (changes) {\n            _this._updateWithValue(changes.value);\n        });\n        this._updateWithValue();\n    };\n    /**\n     * @param {?=} value\n     * @return {?}\n     */\n    FlexAlignDirective.prototype._updateWithValue = function (value) {\n        value = value || this._queryInput('align') || 'stretch';\n        if (this._mqActivation) {\n            value = this._mqActivation.activatedInput;\n        }\n        this._applyStyleToElement(this._buildCSS(value));\n    };\n    /**\n     * @param {?} align\n     * @return {?}\n     */\n    FlexAlignDirective.prototype._buildCSS = function (align) {\n        var /** @type {?} */ css = {};\n        // Cross-axis\n        switch (align) {\n            case 'start':\n                css['align-self'] = 'flex-start';\n                break;\n            case 'end':\n                css['align-self'] = 'flex-end';\n                break;\n            default:\n                css['align-self'] = align;\n                break;\n        }\n        return css;\n    };\n    return FlexAlignDirective;\n}(BaseFxDirective));\nvar FLEX_FILL_CSS = {\n    'margin': 0,\n    'width': '100%',\n    'height': '100%',\n    'min-width': '100%',\n    'min-height': '100%'\n};\n/**\n * 'fxFill' flexbox styling directive\n *  Maximizes width and height of element in a layout container\n *\n *  NOTE: fxFill is NOT responsive API!!\n */\nvar FlexFillDirective = /*@__PURE__*/ (function (_super) {\n    __extends(FlexFillDirective, _super);\n    /**\n     * @param {?} monitor\n     * @param {?} elRef\n     * @param {?} renderer\n     */\n    function FlexFillDirective(monitor, elRef, renderer) {\n        var _this = _super.call(this, monitor, elRef, renderer) || this;\n        _this.elRef = elRef;\n        _this.renderer = renderer;\n        _this._applyStyleToElement(FLEX_FILL_CSS);\n        return _this;\n    }\n    return FlexFillDirective;\n}(BaseFxDirective));\n/**\n * 'flex-offset' flexbox styling directive\n * Configures the 'margin-left' of the element in a layout container\n */\nvar FlexOffsetDirective = /*@__PURE__*/ (function (_super) {\n    __extends(FlexOffsetDirective, _super);\n    /**\n     * @param {?} monitor\n     * @param {?} elRef\n     * @param {?} renderer\n     * @param {?} _container\n     */\n    function FlexOffsetDirective(monitor, elRef, renderer, _container) {\n        var _this = _super.call(this, monitor, elRef, renderer) || this;\n        _this._container = _container;\n        /**\n         * The flex-direction of this element's host container. Defaults to 'row'.\n         */\n        _this._layout = 'row';\n        _this.watchParentFlow();\n        return _this;\n    }\n    Object.defineProperty(FlexOffsetDirective.prototype, \"offset\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('offset', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexOffsetDirective.prototype, \"offsetXs\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('offsetXs', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexOffsetDirective.prototype, \"offsetSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('offsetSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexOffsetDirective.prototype, \"offsetMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('offsetMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexOffsetDirective.prototype, \"offsetLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('offsetLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexOffsetDirective.prototype, \"offsetXl\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('offsetXl', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexOffsetDirective.prototype, \"offsetLtSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('offsetLtSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexOffsetDirective.prototype, \"offsetLtMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('offsetLtMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexOffsetDirective.prototype, \"offsetLtLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('offsetLtLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexOffsetDirective.prototype, \"offsetLtXl\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('offsetLtXl', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexOffsetDirective.prototype, \"offsetGtXs\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('offsetGtXs', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexOffsetDirective.prototype, \"offsetGtSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('offsetGtSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexOffsetDirective.prototype, \"offsetGtMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('offsetGtMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexOffsetDirective.prototype, \"offsetGtLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('offsetGtLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * For \\@Input changes on the current mq activation property, see onMediaQueryChanges()\n     * @param {?} changes\n     * @return {?}\n     */\n    FlexOffsetDirective.prototype.ngOnChanges = function (changes) {\n        if (changes['offset'] != null || this._mqActivation) {\n            this._updateWithValue();\n        }\n    };\n    /**\n     * Cleanup\n     * @return {?}\n     */\n    FlexOffsetDirective.prototype.ngOnDestroy = function () {\n        _super.prototype.ngOnDestroy.call(this);\n        if (this._layoutWatcher) {\n            this._layoutWatcher.unsubscribe();\n        }\n    };\n    /**\n     * After the initial onChanges, build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     * @return {?}\n     */\n    FlexOffsetDirective.prototype.ngOnInit = function () {\n        var _this = this;\n        _super.prototype.ngOnInit.call(this);\n        this._listenForMediaQueryChanges('offset', 0, function (changes) {\n            _this._updateWithValue(changes.value);\n        });\n    };\n    /**\n     * If parent flow-direction changes, then update the margin property\n     * used to offset\n     * @return {?}\n     */\n    FlexOffsetDirective.prototype.watchParentFlow = function () {\n        var _this = this;\n        if (this._container) {\n            // Subscribe to layout immediate parent direction changes (if any)\n            this._layoutWatcher = this._container.layout$.subscribe(function (direction) {\n                // `direction` === null if parent container does not have a `fxLayout`\n                _this._onLayoutChange(direction);\n            });\n        }\n    };\n    /**\n     * Caches the parent container's 'flex-direction' and updates the element's style.\n     * Used as a handler for layout change events from the parent flex container.\n     * @param {?=} direction\n     * @return {?}\n     */\n    FlexOffsetDirective.prototype._onLayoutChange = function (direction) {\n        this._layout = direction || this._layout || 'row';\n        this._updateWithValue();\n    };\n    /**\n     * Using the current fxFlexOffset value, update the inline CSS\n     * NOTE: this will assign `margin-left` if the parent flex-direction == 'row',\n     *       otherwise `margin-top` is used for the offset.\n     * @param {?=} value\n     * @return {?}\n     */\n    FlexOffsetDirective.prototype._updateWithValue = function (value) {\n        value = value || this._queryInput('offset') || 0;\n        if (this._mqActivation) {\n            value = this._mqActivation.activatedInput;\n        }\n        this._applyStyleToElement(this._buildCSS(value));\n    };\n    /**\n     * @param {?} offset\n     * @return {?}\n     */\n    FlexOffsetDirective.prototype._buildCSS = function (offset) {\n        var /** @type {?} */ isPercent = String(offset).indexOf('%') > -1;\n        var /** @type {?} */ isPx = String(offset).indexOf('px') > -1;\n        if (!isPx && !isPercent && !isNaN(offset)) {\n            offset = offset + '%';\n        }\n        // The flex-direction of this element's flex container. Defaults to 'row'.\n        var /** @type {?} */ layout = this._getFlowDirection(this.parentElement, true);\n        return isFlowHorizontal(layout) ? { 'margin-left': \"\" + offset } : { 'margin-top': \"\" + offset };\n    };\n    return FlexOffsetDirective;\n}(BaseFxDirective));\n/**\n * 'flex-order' flexbox styling directive\n * Configures the positional ordering of the element in a sorted layout container\n * @see https://css-tricks.com/almanac/properties/o/order/\n */\nvar FlexOrderDirective = /*@__PURE__*/ (function (_super) {\n    __extends(FlexOrderDirective, _super);\n    /**\n     * @param {?} monitor\n     * @param {?} elRef\n     * @param {?} renderer\n     */\n    function FlexOrderDirective(monitor, elRef, renderer) {\n        return _super.call(this, monitor, elRef, renderer) || this;\n    }\n    Object.defineProperty(FlexOrderDirective.prototype, \"order\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('order', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexOrderDirective.prototype, \"orderXs\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('orderXs', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexOrderDirective.prototype, \"orderSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('orderSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexOrderDirective.prototype, \"orderMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('orderMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexOrderDirective.prototype, \"orderLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('orderLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexOrderDirective.prototype, \"orderXl\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('orderXl', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexOrderDirective.prototype, \"orderGtXs\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('orderGtXs', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexOrderDirective.prototype, \"orderGtSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('orderGtSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexOrderDirective.prototype, \"orderGtMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('orderGtMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexOrderDirective.prototype, \"orderGtLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('orderGtLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexOrderDirective.prototype, \"orderLtSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('orderLtSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexOrderDirective.prototype, \"orderLtMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('orderLtMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexOrderDirective.prototype, \"orderLtLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('orderLtLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FlexOrderDirective.prototype, \"orderLtXl\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('orderLtXl', val); },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * For \\@Input changes on the current mq activation property, see onMediaQueryChanges()\n     * @param {?} changes\n     * @return {?}\n     */\n    FlexOrderDirective.prototype.ngOnChanges = function (changes) {\n        if (changes['order'] != null || this._mqActivation) {\n            this._updateWithValue();\n        }\n    };\n    /**\n     * After the initial onChanges, build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     * @return {?}\n     */\n    FlexOrderDirective.prototype.ngOnInit = function () {\n        var _this = this;\n        _super.prototype.ngOnInit.call(this);\n        this._listenForMediaQueryChanges('order', '0', function (changes) {\n            _this._updateWithValue(changes.value);\n        });\n        this._updateWithValue();\n    };\n    /**\n     * @param {?=} value\n     * @return {?}\n     */\n    FlexOrderDirective.prototype._updateWithValue = function (value) {\n        value = value || this._queryInput('order') || '0';\n        if (this._mqActivation) {\n            value = this._mqActivation.activatedInput;\n        }\n        this._applyStyleToElement(this._buildCSS(value));\n    };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    FlexOrderDirective.prototype._buildCSS = function (value) {\n        value = parseInt(value, 10);\n        return { order: isNaN(value) ? 0 : value };\n    };\n    return FlexOrderDirective;\n}(BaseFxDirective));\n/**\n * Adapts the 'deprecated' Angular Renderer v1 API to use the new Renderer2 instance\n * This is required for older versions of NgStyle and NgClass that require\n * the v1 API (but should use the v2 instances)\n */\nvar RendererAdapter = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} _renderer\n     */\n    function RendererAdapter(_renderer) {\n        this._renderer = _renderer;\n    }\n    /**\n     * @param {?} el\n     * @param {?} className\n     * @param {?} isAdd\n     * @return {?}\n     */\n    RendererAdapter.prototype.setElementClass = function (el, className, isAdd) {\n        if (isAdd) {\n            this._renderer.addClass(el, className);\n        }\n        else {\n            this._renderer.removeClass(el, className);\n        }\n    };\n    /**\n     * @param {?} el\n     * @param {?} styleName\n     * @param {?} styleValue\n     * @return {?}\n     */\n    RendererAdapter.prototype.setElementStyle = function (el, styleName, styleValue) {\n        if (styleValue) {\n            this._renderer.setStyle(el, styleName, styleValue);\n        }\n        else {\n            this._renderer.removeStyle(el, styleName);\n        }\n    };\n    /**\n     * @param {?} el\n     * @param {?} name\n     * @return {?}\n     */\n    RendererAdapter.prototype.addClass = function (el, name) {\n        this._renderer.addClass(el, name);\n    };\n    /**\n     * @param {?} el\n     * @param {?} name\n     * @return {?}\n     */\n    RendererAdapter.prototype.removeClass = function (el, name) {\n        this._renderer.removeClass(el, name);\n    };\n    /**\n     * @param {?} el\n     * @param {?} style\n     * @param {?} value\n     * @param {?=} flags\n     * @return {?}\n     */\n    RendererAdapter.prototype.setStyle = function (el, style, value, flags) {\n        this._renderer.setStyle(el, style, value, flags);\n    };\n    /**\n     * @param {?} el\n     * @param {?} style\n     * @param {?=} flags\n     * @return {?}\n     */\n    RendererAdapter.prototype.removeStyle = function (el, style, flags) {\n        this._renderer.removeStyle(el, style, flags);\n    };\n    /**\n     * @return {?}\n     */\n    RendererAdapter.prototype.animate = function () { throw _notImplemented('animate'); };\n    /**\n     * @return {?}\n     */\n    RendererAdapter.prototype.attachViewAfter = function () { throw _notImplemented('attachViewAfter'); };\n    /**\n     * @return {?}\n     */\n    RendererAdapter.prototype.detachView = function () { throw _notImplemented('detachView'); };\n    /**\n     * @return {?}\n     */\n    RendererAdapter.prototype.destroyView = function () { throw _notImplemented('destroyView'); };\n    /**\n     * @return {?}\n     */\n    RendererAdapter.prototype.createElement = function () { throw _notImplemented('createElement'); };\n    /**\n     * @return {?}\n     */\n    RendererAdapter.prototype.createViewRoot = function () { throw _notImplemented('createViewRoot'); };\n    /**\n     * @return {?}\n     */\n    RendererAdapter.prototype.createTemplateAnchor = function () { throw _notImplemented('createTemplateAnchor'); };\n    /**\n     * @return {?}\n     */\n    RendererAdapter.prototype.createText = function () { throw _notImplemented('createText'); };\n    /**\n     * @return {?}\n     */\n    RendererAdapter.prototype.invokeElementMethod = function () { throw _notImplemented('invokeElementMethod'); };\n    /**\n     * @return {?}\n     */\n    RendererAdapter.prototype.projectNodes = function () { throw _notImplemented('projectNodes'); };\n    /**\n     * @return {?}\n     */\n    RendererAdapter.prototype.selectRootElement = function () { throw _notImplemented('selectRootElement'); };\n    /**\n     * @return {?}\n     */\n    RendererAdapter.prototype.setBindingDebugInfo = function () { throw _notImplemented('setBindingDebugInfo'); };\n    /**\n     * @return {?}\n     */\n    RendererAdapter.prototype.setElementProperty = function () { throw _notImplemented('setElementProperty'); };\n    /**\n     * @return {?}\n     */\n    RendererAdapter.prototype.setElementAttribute = function () { throw _notImplemented('setElementAttribute'); };\n    /**\n     * @return {?}\n     */\n    RendererAdapter.prototype.setText = function () { throw _notImplemented('setText'); };\n    /**\n     * @return {?}\n     */\n    RendererAdapter.prototype.listen = function () { throw _notImplemented('listen'); };\n    /**\n     * @return {?}\n     */\n    RendererAdapter.prototype.listenGlobal = function () { throw _notImplemented('listenGlobal'); };\n    return RendererAdapter;\n}());\n/**\n * @param {?} methodName\n * @return {?}\n */\nfunction _notImplemented(methodName) {\n    return new Error(\"The method RendererAdapter::\" + methodName + \"() has not been implemented\");\n}\n/**\n * Directive to add responsive support for ngClass.\n * This maintains the core functionality of 'ngClass' and adds responsive API\n *\n */\nvar ClassDirective = /*@__PURE__*/ (function (_super) {\n    __extends(ClassDirective, _super);\n    /**\n     * @param {?} monitor\n     * @param {?} _iterableDiffers\n     * @param {?} _keyValueDiffers\n     * @param {?} _ngEl\n     * @param {?} _renderer\n     * @param {?} _ngClassInstance\n     */\n    function ClassDirective(monitor, _iterableDiffers, _keyValueDiffers, _ngEl, _renderer, _ngClassInstance) {\n        var _this = _super.call(this, monitor, _ngEl, _renderer) || this;\n        _this.monitor = monitor;\n        _this._iterableDiffers = _iterableDiffers;\n        _this._keyValueDiffers = _keyValueDiffers;\n        _this._ngEl = _ngEl;\n        _this._renderer = _renderer;\n        _this._ngClassInstance = _ngClassInstance;\n        _this._configureAdapters();\n        return _this;\n    }\n    Object.defineProperty(ClassDirective.prototype, \"ngClassBase\", {\n        /**\n         * Intercept ngClass assignments so we cache the default classes\n         * which are merged with activated styles or used as fallbacks.\n         * Note: Base ngClass values are applied during ngDoCheck()\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) {\n            var /** @type {?} */ key = 'ngClass';\n            this._base.cacheInput(key, val, true);\n            this._ngClassInstance.ngClass = this._base.queryInput(key);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ClassDirective.prototype, \"klazz\", {\n        /**\n         * Capture class assignments so we cache the default classes\n         * which are merged with activated styles and used as fallbacks.\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) {\n            var /** @type {?} */ key = 'class';\n            this._base.cacheInput(key, val);\n            this._ngClassInstance.klass = val;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ClassDirective.prototype, \"ngClassXs\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._base.cacheInput('ngClassXs', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ClassDirective.prototype, \"ngClassSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._base.cacheInput('ngClassSm', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ClassDirective.prototype, \"ngClassMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._base.cacheInput('ngClassMd', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ClassDirective.prototype, \"ngClassLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._base.cacheInput('ngClassLg', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ClassDirective.prototype, \"ngClassXl\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._base.cacheInput('ngClassXl', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ClassDirective.prototype, \"ngClassLtSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._base.cacheInput('ngClassLtSm', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ClassDirective.prototype, \"ngClassLtMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._base.cacheInput('ngClassLtMd', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ClassDirective.prototype, \"ngClassLtLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._base.cacheInput('ngClassLtLg', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ClassDirective.prototype, \"ngClassLtXl\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._base.cacheInput('ngClassLtXl', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ClassDirective.prototype, \"ngClassGtXs\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._base.cacheInput('ngClassGtXs', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ClassDirective.prototype, \"ngClassGtSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._base.cacheInput('ngClassGtSm', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ClassDirective.prototype, \"ngClassGtMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._base.cacheInput('ngClassGtMd', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ClassDirective.prototype, \"ngClassGtLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._base.cacheInput('ngClassGtLg', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * For \\@Input changes on the current mq activation property\n     * @param {?} changes\n     * @return {?}\n     */\n    ClassDirective.prototype.ngOnChanges = function (changes) {\n        if (this._base.activeKey in changes) {\n            this._ngClassInstance.ngClass = this._base.mqActivation.activatedInput || '';\n        }\n    };\n    /**\n     * @return {?}\n     */\n    ClassDirective.prototype.ngOnInit = function () {\n        this._configureMQListener();\n    };\n    /**\n     * For ChangeDetectionStrategy.onPush and ngOnChanges() updates\n     * @return {?}\n     */\n    ClassDirective.prototype.ngDoCheck = function () {\n        this._ngClassInstance.ngDoCheck();\n    };\n    /**\n     * @return {?}\n     */\n    ClassDirective.prototype.ngOnDestroy = function () {\n        this._base.ngOnDestroy();\n        this._ngClassInstance = null;\n    };\n    /**\n     * Configure adapters (that delegate to an internal ngClass instance) if responsive\n     * keys have been defined.\n     * @return {?}\n     */\n    ClassDirective.prototype._configureAdapters = function () {\n        this._base = new BaseFxDirectiveAdapter('ngClass', this.monitor, this._ngEl, this._renderer);\n        if (!this._ngClassInstance) {\n            // Create an instance NgClass Directive instance only if `ngClass=\"\"` has NOT been defined on\n            // the same host element; since the responsive variations may be defined...\n            var /** @type {?} */ adapter = new RendererAdapter(this._renderer);\n            this._ngClassInstance = new NgClass(this._iterableDiffers, this._keyValueDiffers, this._ngEl, /** @type {?} */ (adapter));\n        }\n    };\n    /**\n     * Build an mqActivation object that bridges mql change events to onMediaQueryChange handlers\n     * NOTE: We delegate subsequent activity to the NgClass logic\n     *       Identify the activated input value and update the ngClass iterables...\n     *       Use ngDoCheck() to actually apply the values to the element\n     * @param {?=} baseKey\n     * @return {?}\n     */\n    ClassDirective.prototype._configureMQListener = function (baseKey) {\n        var _this = this;\n        if (baseKey === void 0) {\n            baseKey = 'ngClass';\n        }\n        var /** @type {?} */ fallbackValue = this._base.queryInput(baseKey);\n        this._base.listenForMediaQueryChanges(baseKey, fallbackValue, function (changes) {\n            _this._ngClassInstance.ngClass = changes.value || '';\n            _this._ngClassInstance.ngDoCheck();\n        });\n    };\n    return ClassDirective;\n}(BaseFxDirective));\n/**\n * NgStyle allowed inputs\n */\nvar NgStyleKeyValue = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} key\n     * @param {?} value\n     * @param {?=} noQuotes\n     */\n    function NgStyleKeyValue(key, value, noQuotes) {\n        if (noQuotes === void 0) {\n            noQuotes = true;\n        }\n        this.key = key;\n        this.value = value;\n        this.key = noQuotes ? key.replace(/['\"]/g, '').trim() : key.trim();\n        this.value = noQuotes ? value.replace(/['\"]/g, '').trim() : value.trim();\n        this.value = this.value.replace(/;/, '');\n    }\n    return NgStyleKeyValue;\n}());\n/**\n * Transform Operators for \\@angular/flex-layout NgStyle Directive\n */\nvar ngStyleUtils = {\n    getType: getType,\n    buildRawList: buildRawList,\n    buildMapFromList: buildMapFromList,\n    buildMapFromSet: buildMapFromSet\n};\n/**\n * @param {?} target\n * @return {?}\n */\nfunction getType(target) {\n    var /** @type {?} */ what = typeof target;\n    if (what === 'object') {\n        return (target.constructor === Array) ? 'array' :\n            (target.constructor === Set) ? 'set' : 'object';\n    }\n    return what;\n}\n/**\n * Split string of key:value pairs into Array of k-v pairs\n * e.g.  'key:value; key:value; key:value;' -> ['key:value',...]\n * @param {?} source\n * @param {?=} delimiter\n * @return {?}\n */\nfunction buildRawList(source, delimiter) {\n    if (delimiter === void 0) {\n        delimiter = ';';\n    }\n    return String(source)\n        .trim()\n        .split(delimiter)\n        .map(function (val) { return val.trim(); })\n        .filter(function (val) { return val !== ''; });\n}\n/**\n * Convert array of key:value strings to a iterable map object\n * @param {?} styles\n * @param {?=} sanitize\n * @return {?}\n */\nfunction buildMapFromList(styles, sanitize) {\n    var /** @type {?} */ sanitizeValue = function (it) {\n        if (sanitize) {\n            it.value = sanitize(it.value);\n        }\n        return it;\n    };\n    return styles\n        .map(stringToKeyValue)\n        .filter(function (entry) { return !!entry; })\n        .map(sanitizeValue)\n        .reduce(keyValuesToMap, {});\n}\n/**\n * Convert Set<string> or raw Object to an iterable NgStyleMap\n * @param {?} source\n * @param {?=} sanitize\n * @return {?}\n */\nfunction buildMapFromSet(source, sanitize) {\n    var /** @type {?} */ list = new Array();\n    if (getType(source) == 'set') {\n        source.forEach(function (entry) { return list.push(entry); });\n    }\n    else {\n        Object.keys(source).forEach(function (key) {\n            list.push(key + \":\" + source[key]);\n        });\n    }\n    return buildMapFromList(list, sanitize);\n}\n/**\n * Convert 'key:value' -> [key, value]\n * @param {?} it\n * @return {?}\n */\nfunction stringToKeyValue(it) {\n    var _a = it.split(':'), key = _a[0], val = _a[1];\n    return val ? new NgStyleKeyValue(key, val) : null;\n}\n/**\n * Convert [ [key,value] ] -> { key : value }\n * @param {?} map\n * @param {?} entry\n * @return {?}\n */\nfunction keyValuesToMap(map$$1, entry) {\n    if (!!entry.key) {\n        map$$1[entry.key] = entry.value;\n    }\n    return map$$1;\n}\n/**\n * Directive to add responsive support for ngStyle.\n *\n */\nvar StyleDirective = /*@__PURE__*/ (function (_super) {\n    __extends(StyleDirective, _super);\n    /**\n     *  Constructor for the ngStyle subclass; which adds selectors and\n     *  a MediaQuery Activation Adapter\n     * @param {?} monitor\n     * @param {?} _sanitizer\n     * @param {?} _ngEl\n     * @param {?} _renderer\n     * @param {?} _differs\n     * @param {?} _ngStyleInstance\n     */\n    function StyleDirective(monitor, _sanitizer, _ngEl, _renderer, _differs, _ngStyleInstance) {\n        var _this = _super.call(this, monitor, _ngEl, _renderer) || this;\n        _this.monitor = monitor;\n        _this._sanitizer = _sanitizer;\n        _this._ngEl = _ngEl;\n        _this._renderer = _renderer;\n        _this._differs = _differs;\n        _this._ngStyleInstance = _ngStyleInstance;\n        _this._configureAdapters();\n        return _this;\n    }\n    Object.defineProperty(StyleDirective.prototype, \"ngStyleBase\", {\n        /**\n         * Intercept ngStyle assignments so we cache the default styles\n         * which are merged with activated styles or used as fallbacks.\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) {\n            var /** @type {?} */ key = 'ngStyle';\n            this._base.cacheInput(key, val, true); // convert val to hashmap\n            this._ngStyleInstance.ngStyle = this._base.queryInput(key);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StyleDirective.prototype, \"ngStyleXs\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._base.cacheInput('ngStyleXs', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StyleDirective.prototype, \"ngStyleSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._base.cacheInput('ngStyleSm', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StyleDirective.prototype, \"ngStyleMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._base.cacheInput('ngStyleMd', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StyleDirective.prototype, \"ngStyleLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._base.cacheInput('ngStyleLg', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StyleDirective.prototype, \"ngStyleXl\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._base.cacheInput('ngStyleXl', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StyleDirective.prototype, \"ngStyleLtSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._base.cacheInput('ngStyleLtSm', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StyleDirective.prototype, \"ngStyleLtMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._base.cacheInput('ngStyleLtMd', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StyleDirective.prototype, \"ngStyleLtLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._base.cacheInput('ngStyleLtLg', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StyleDirective.prototype, \"ngStyleLtXl\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._base.cacheInput('ngStyleLtXl', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StyleDirective.prototype, \"ngStyleGtXs\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._base.cacheInput('ngStyleGtXs', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StyleDirective.prototype, \"ngStyleGtSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._base.cacheInput('ngStyleGtSm', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StyleDirective.prototype, \"ngStyleGtMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._base.cacheInput('ngStyleGtMd', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StyleDirective.prototype, \"ngStyleGtLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._base.cacheInput('ngStyleGtLg', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * For \\@Input changes on the current mq activation property\n     * @param {?} changes\n     * @return {?}\n     */\n    StyleDirective.prototype.ngOnChanges = function (changes) {\n        if (this._base.activeKey in changes) {\n            this._ngStyleInstance.ngStyle = this._base.mqActivation.activatedInput || '';\n        }\n    };\n    /**\n     * @return {?}\n     */\n    StyleDirective.prototype.ngOnInit = function () {\n        this._configureMQListener();\n    };\n    /**\n     * For ChangeDetectionStrategy.onPush and ngOnChanges() updates\n     * @return {?}\n     */\n    StyleDirective.prototype.ngDoCheck = function () {\n        this._ngStyleInstance.ngDoCheck();\n    };\n    /**\n     * @return {?}\n     */\n    StyleDirective.prototype.ngOnDestroy = function () {\n        this._base.ngOnDestroy();\n        this._ngStyleInstance = null;\n    };\n    /**\n     * Configure adapters (that delegate to an internal ngClass instance) if responsive\n     * keys have been defined.\n     * @return {?}\n     */\n    StyleDirective.prototype._configureAdapters = function () {\n        this._base = new BaseFxDirectiveAdapter('ngStyle', this.monitor, this._ngEl, this._renderer);\n        if (!this._ngStyleInstance) {\n            // Create an instance NgClass Directive instance only if `ngClass=\"\"` has NOT been\n            // defined on the same host element; since the responsive variations may be defined...\n            var /** @type {?} */ adapter = new RendererAdapter(this._renderer);\n            this._ngStyleInstance = new NgStyle(this._differs, this._ngEl, /** @type {?} */ (adapter));\n        }\n        this._buildCacheInterceptor();\n        this._fallbackToStyle();\n    };\n    /**\n     * Build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     * @param {?=} baseKey\n     * @return {?}\n     */\n    StyleDirective.prototype._configureMQListener = function (baseKey) {\n        var _this = this;\n        if (baseKey === void 0) {\n            baseKey = 'ngStyle';\n        }\n        var /** @type {?} */ fallbackValue = this._base.queryInput(baseKey);\n        this._base.listenForMediaQueryChanges(baseKey, fallbackValue, function (changes) {\n            _this._ngStyleInstance.ngStyle = changes.value || '';\n            _this._ngStyleInstance.ngDoCheck();\n        });\n    };\n    /**\n     * Build intercept to convert raw strings to ngStyleMap\n     * @return {?}\n     */\n    StyleDirective.prototype._buildCacheInterceptor = function () {\n        var _this = this;\n        var /** @type {?} */ cacheInput = this._base.cacheInput.bind(this._base);\n        this._base.cacheInput = function (key, source, cacheRaw, merge) {\n            if (cacheRaw === void 0) {\n                cacheRaw = false;\n            }\n            if (merge === void 0) {\n                merge = true;\n            }\n            var /** @type {?} */ styles = _this._buildStyleMap(source);\n            if (merge) {\n                styles = extendObject({}, _this._base.inputMap['ngStyle'], styles);\n            }\n            cacheInput(key, styles, cacheRaw);\n        };\n    };\n    /**\n     * Convert raw strings to ngStyleMap; which is required by ngStyle\n     * NOTE: Raw string key-value pairs MUST be delimited by `;`\n     *       Comma-delimiters are not supported due to complexities of\n     *       possible style values such as `rgba(x,x,x,x)` and others\n     * @param {?} styles\n     * @return {?}\n     */\n    StyleDirective.prototype._buildStyleMap = function (styles) {\n        var _this = this;\n        var /** @type {?} */ sanitizer = function (val) {\n            // Always safe-guard (aka sanitize) style property values\n            return _this._sanitizer.sanitize(SecurityContext.STYLE, val);\n        };\n        if (styles) {\n            switch (ngStyleUtils.getType(styles)) {\n                case 'string': return ngStyleUtils.buildMapFromList(ngStyleUtils.buildRawList(styles), sanitizer);\n                case 'array': return ngStyleUtils.buildMapFromList(/** @type {?} */ (styles), sanitizer);\n                case 'set': return ngStyleUtils.buildMapFromSet(styles, sanitizer);\n                default: return ngStyleUtils.buildMapFromSet(styles, sanitizer);\n            }\n        }\n        return styles;\n    };\n    /**\n     * Initial lookup of raw 'class' value (if any)\n     * @return {?}\n     */\n    StyleDirective.prototype._fallbackToStyle = function () {\n        if (!this._base.queryInput('ngStyle')) {\n            this.ngStyleBase = this._getAttributeValue('style') || '';\n        }\n    };\n    return StyleDirective;\n}(BaseFxDirective));\nvar FALSY = ['false', false, 0];\n/**\n * For fxHide selectors, we invert the 'value'\n * and assign to the equivalent fxShow selector cache\n *  - When 'hide' === '' === true, do NOT show the element\n *  - When 'hide' === false or 0... we WILL show the element\n * @param {?} hide\n * @return {?}\n */\nfunction negativeOf(hide) {\n    return (hide === '') ? false :\n        ((hide === 'false') || (hide === 0)) ? true : !hide;\n}\n/**\n * 'show' Layout API directive\n *\n */\nvar ShowHideDirective = /*@__PURE__*/ (function (_super) {\n    __extends(ShowHideDirective, _super);\n    /**\n     *\n     * @param {?} monitor\n     * @param {?} _layout\n     * @param {?} elRef\n     * @param {?} renderer\n     */\n    function ShowHideDirective(monitor, _layout, elRef, renderer) {\n        var _this = _super.call(this, monitor, elRef, renderer) || this;\n        _this._layout = _layout;\n        _this.elRef = elRef;\n        _this.renderer = renderer;\n        if (_layout) {\n            /**\n             * The Layout can set the display:flex (and incorrectly affect the Hide/Show directives.\n             * Whenever Layout [on the same element] resets its CSS, then update the Hide/Show CSS\n             */\n            _this._layoutWatcher = _layout.layout$.subscribe(function () { return _this._updateWithValue(); });\n        }\n        return _this;\n    }\n    Object.defineProperty(ShowHideDirective.prototype, \"show\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('show', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"showXs\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('showXs', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"showSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('showSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"showMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('showMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"showLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('showLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"showXl\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('showXl', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"showLtSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('showLtSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"showLtMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('showLtMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"showLtLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('showLtLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"showLtXl\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('showLtXl', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"showGtXs\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('showGtXs', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"showGtSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('showGtSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"showGtMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('showGtMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"showGtLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('showGtLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"hide\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('show', negativeOf(val)); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"hideXs\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('showXs', negativeOf(val)); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"hideSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('showSm', negativeOf(val)); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"hideMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('showMd', negativeOf(val)); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"hideLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('showLg', negativeOf(val)); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"hideXl\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('showXl', negativeOf(val)); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"hideLtSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('showLtSm', negativeOf(val)); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"hideLtMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('showLtMd', negativeOf(val)); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"hideLtLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('showLtLg', negativeOf(val)); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"hideLtXl\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('showLtXl', negativeOf(val)); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"hideGtXs\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('showGtXs', negativeOf(val)); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"hideGtSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('showGtSm', negativeOf(val)); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"hideGtMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('showGtMd', negativeOf(val)); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"hideGtLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('showGtLg', negativeOf(val)); },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Override accessor to the current HTMLElement's `display` style\n     * Note: Show/Hide will not change the display to 'flex' but will set it to 'block'\n     * unless it was already explicitly specified inline or in a CSS stylesheet.\n     * @return {?}\n     */\n    ShowHideDirective.prototype._getDisplayStyle = function () {\n        return this._layout ? 'flex' : _super.prototype._getDisplayStyle.call(this);\n    };\n    /**\n     * On changes to any \\@Input properties...\n     * Default to use the non-responsive Input value ('fxShow')\n     * Then conditionally override with the mq-activated Input's current value\n     * @param {?} changes\n     * @return {?}\n     */\n    ShowHideDirective.prototype.ngOnChanges = function (changes) {\n        if (this.hasInitialized && (changes['show'] != null || this._mqActivation)) {\n            this._updateWithValue();\n        }\n    };\n    /**\n     * After the initial onChanges, build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     * @return {?}\n     */\n    ShowHideDirective.prototype.ngOnInit = function () {\n        var _this = this;\n        _super.prototype.ngOnInit.call(this);\n        var /** @type {?} */ value = this._getDefaultVal('show', true);\n        // Build _mqActivation controller\n        this._listenForMediaQueryChanges('show', value, function (changes) {\n            _this._updateWithValue(changes.value);\n        });\n        this._updateWithValue();\n    };\n    /**\n     * @return {?}\n     */\n    ShowHideDirective.prototype.ngOnDestroy = function () {\n        _super.prototype.ngOnDestroy.call(this);\n        if (this._layoutWatcher) {\n            this._layoutWatcher.unsubscribe();\n        }\n    };\n    /**\n     * Validate the visibility value and then update the host's inline display style\n     * @param {?=} value\n     * @return {?}\n     */\n    ShowHideDirective.prototype._updateWithValue = function (value) {\n        value = value || this._getDefaultVal('show', true);\n        if (this._mqActivation) {\n            value = this._mqActivation.activatedInput;\n        }\n        var /** @type {?} */ shouldShow = this._validateTruthy(value);\n        this._applyStyleToElement(this._buildCSS(shouldShow));\n    };\n    /**\n     * Build the CSS that should be assigned to the element instance\n     * @param {?} show\n     * @return {?}\n     */\n    ShowHideDirective.prototype._buildCSS = function (show) {\n        return { 'display': show ? this._display : 'none' };\n    };\n    /**\n     * Validate the to be not FALSY\n     * @param {?} show\n     * @return {?}\n     */\n    ShowHideDirective.prototype._validateTruthy = function (show) {\n        return (FALSY.indexOf(show) == -1);\n    };\n    return ShowHideDirective;\n}(BaseFxDirective));\n/**\n * This directive provides a responsive API for the HTML <img> 'src' attribute\n * and will update the img.src property upon each responsive activation.\n *\n * e.g.\n *      <img src=\"defaultScene.jpg\" src.xs=\"mobileScene.jpg\"></img>\n *\n * @see https://css-tricks.com/responsive-images-youre-just-changing-resolutions-use-src/\n */\nvar ImgSrcDirective = /*@__PURE__*/ (function (_super) {\n    __extends(ImgSrcDirective, _super);\n    /**\n     * @param {?} elRef\n     * @param {?} renderer\n     * @param {?} monitor\n     */\n    function ImgSrcDirective(elRef, renderer, monitor) {\n        var _this = _super.call(this, monitor, elRef, renderer) || this;\n        _this._cacheInput('src', elRef.nativeElement.getAttribute('src') || '');\n        return _this;\n    }\n    Object.defineProperty(ImgSrcDirective.prototype, \"srcBase\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this.cacheDefaultSrc(val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImgSrcDirective.prototype, \"srcXs\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('srcXs', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImgSrcDirective.prototype, \"srcSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('srcSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImgSrcDirective.prototype, \"srcMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('srcMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImgSrcDirective.prototype, \"srcLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('srcLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImgSrcDirective.prototype, \"srcXl\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('srcXl', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImgSrcDirective.prototype, \"srcLtSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('srcLtSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImgSrcDirective.prototype, \"srcLtMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('srcLtMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImgSrcDirective.prototype, \"srcLtLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('srcLtLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImgSrcDirective.prototype, \"srcLtXl\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('srcLtXl', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImgSrcDirective.prototype, \"srcGtXs\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('srcGtXs', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImgSrcDirective.prototype, \"srcGtSm\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('srcGtSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImgSrcDirective.prototype, \"srcGtMd\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('srcGtMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImgSrcDirective.prototype, \"srcGtLg\", {\n        /**\n         * @param {?} val\n         * @return {?}\n         */\n        set: function (val) { this._cacheInput('srcGtLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Listen for responsive changes to update the img.src attribute\n     * @return {?}\n     */\n    ImgSrcDirective.prototype.ngOnInit = function () {\n        var _this = this;\n        _super.prototype.ngOnInit.call(this);\n        if (this.hasResponsiveKeys) {\n            // Listen for responsive changes\n            this._listenForMediaQueryChanges('src', this.defaultSrc, function () {\n                _this._updateSrcFor();\n            });\n        }\n        this._updateSrcFor();\n    };\n    /**\n     * Update the 'src' property of the host <img> element\n     * @return {?}\n     */\n    ImgSrcDirective.prototype.ngOnChanges = function () {\n        if (this.hasInitialized) {\n            this._updateSrcFor();\n        }\n    };\n    /**\n     * Use the [responsively] activated input value to update\n     * the host img src attribute or assign a default `img.src=''`\n     * if the src has not been defined.\n     *\n     * Do nothing to standard `<img src=\"\">` usages, only when responsive\n     * keys are present do we actually call `setAttribute()`\n     * @return {?}\n     */\n    ImgSrcDirective.prototype._updateSrcFor = function () {\n        if (this.hasResponsiveKeys) {\n            var /** @type {?} */ url = this.activatedValue || this.defaultSrc;\n            this._renderer.setAttribute(this.nativeElement, 'src', String(url));\n        }\n    };\n    /**\n     * Cache initial value of 'src', this will be used as fallback when breakpoint\n     * activations change.\n     * NOTE: The default 'src' property is not bound using \\@Input(), so perform\n     * a post-ngOnInit() lookup of the default src value (if any).\n     * @param {?=} value\n     * @return {?}\n     */\n    ImgSrcDirective.prototype.cacheDefaultSrc = function (value) {\n        this._cacheInput('src', value || '');\n    };\n    Object.defineProperty(ImgSrcDirective.prototype, \"defaultSrc\", {\n        /**\n         * Empty values are maintained, undefined values are exposed as ''\n         * @return {?}\n         */\n        get: function () {\n            return this._queryInput('src') || '';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImgSrcDirective.prototype, \"hasResponsiveKeys\", {\n        /**\n         * Does the <img> have 1 or more src.<xxx> responsive inputs\n         * defined... these will be mapped to activated breakpoints.\n         * @return {?}\n         */\n        get: function () {\n            return Object.keys(this._inputMap).length > 1;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return ImgSrcDirective;\n}(BaseFxDirective));\nvar RESPONSIVE_ALIASES = [\n    'xs', 'gt-xs', 'sm', 'gt-sm', 'md', 'gt-md', 'lg', 'gt-lg', 'xl'\n];\nvar DEFAULT_BREAKPOINTS = [\n    {\n        alias: 'xs',\n        mediaQuery: '(min-width: 0px) and (max-width: 599px)'\n    },\n    {\n        alias: 'gt-xs',\n        overlapping: true,\n        mediaQuery: '(min-width: 600px)'\n    },\n    {\n        alias: 'lt-sm',\n        overlapping: true,\n        mediaQuery: '(max-width: 599px)'\n    },\n    {\n        alias: 'sm',\n        mediaQuery: '(min-width: 600px) and (max-width: 959px)'\n    },\n    {\n        alias: 'gt-sm',\n        overlapping: true,\n        mediaQuery: '(min-width: 960px)'\n    },\n    {\n        alias: 'lt-md',\n        overlapping: true,\n        mediaQuery: '(max-width: 959px)'\n    },\n    {\n        alias: 'md',\n        mediaQuery: '(min-width: 960px) and (max-width: 1279px)'\n    },\n    {\n        alias: 'gt-md',\n        overlapping: true,\n        mediaQuery: '(min-width: 1280px)'\n    },\n    {\n        alias: 'lt-lg',\n        overlapping: true,\n        mediaQuery: '(max-width: 1279px)'\n    },\n    {\n        alias: 'lg',\n        mediaQuery: '(min-width: 1280px) and (max-width: 1919px)'\n    },\n    {\n        alias: 'gt-lg',\n        overlapping: true,\n        mediaQuery: '(min-width: 1920px)'\n    },\n    {\n        alias: 'lt-xl',\n        overlapping: true,\n        mediaQuery: '(max-width: 1920px)'\n    },\n    {\n        alias: 'xl',\n        mediaQuery: '(min-width: 1920px) and (max-width: 5000px)'\n    }\n];\n/* tslint:disable */\nvar HANDSET_PORTRAIT = '(orientations: portrait) and (max-width: 599px)';\nvar HANDSET_LANDSCAPE = '(orientations: landscape) and (max-width: 959px)';\nvar TABLET_LANDSCAPE = '(orientations: landscape) and (min-width: 960px) and (max-width: 1279px)';\nvar TABLET_PORTRAIT = '(orientations: portrait) and (min-width: 600px) and (max-width: 839px)';\nvar WEB_PORTRAIT = '(orientations: portrait) and (min-width: 840px)';\nvar WEB_LANDSCAPE = '(orientations: landscape) and (min-width: 1280px)';\nvar ScreenTypes = {\n    'HANDSET': HANDSET_PORTRAIT + \", \" + HANDSET_LANDSCAPE,\n    'TABLET': TABLET_PORTRAIT + \" , \" + TABLET_LANDSCAPE,\n    'WEB': WEB_PORTRAIT + \", \" + WEB_LANDSCAPE + \" \",\n    'HANDSET_PORTRAIT': \"\" + HANDSET_PORTRAIT,\n    'TABLET_PORTRAIT': TABLET_PORTRAIT + \" \",\n    'WEB_PORTRAIT': \"\" + WEB_PORTRAIT,\n    'HANDSET_LANDSCAPE': HANDSET_LANDSCAPE + \"]\",\n    'TABLET_LANDSCAPE': \"\" + TABLET_LANDSCAPE,\n    'WEB_LANDSCAPE': \"\" + WEB_LANDSCAPE\n};\n/**\n * Extended Breakpoints for handset/tablets with landscape or portrait orientations\n */\nvar ORIENTATION_BREAKPOINTS = [\n    { 'alias': 'handset', 'mediaQuery': ScreenTypes.HANDSET },\n    { 'alias': 'handset.landscape', 'mediaQuery': ScreenTypes.HANDSET_LANDSCAPE },\n    { 'alias': 'handset.portrait', 'mediaQuery': ScreenTypes.HANDSET_PORTRAIT },\n    { 'alias': 'tablet', 'mediaQuery': ScreenTypes.TABLET },\n    { 'alias': 'tablet.landscape', 'mediaQuery': ScreenTypes.TABLET },\n    { 'alias': 'tablet.portrait', 'mediaQuery': ScreenTypes.TABLET_PORTRAIT },\n    { 'alias': 'web', 'mediaQuery': ScreenTypes.WEB, overlapping: true },\n    { 'alias': 'web.landscape', 'mediaQuery': ScreenTypes.WEB_LANDSCAPE, overlapping: true },\n    { 'alias': 'web.portrait', 'mediaQuery': ScreenTypes.WEB_PORTRAIT, overlapping: true }\n];\n/**\n * Base class for MediaService and pseudo-token for\n * @abstract\n */\nvar ObservableMedia = /*@__PURE__*/ (function () {\n    function ObservableMedia() {\n    }\n    /**\n     * @abstract\n     * @param {?} query\n     * @return {?}\n     */\n    ObservableMedia.prototype.isActive = function (query) { };\n    /**\n     * @abstract\n     * @return {?}\n     */\n    ObservableMedia.prototype.asObservable = function () { };\n    /**\n     * @abstract\n     * @param {?=} next\n     * @param {?=} error\n     * @param {?=} complete\n     * @return {?}\n     */\n    ObservableMedia.prototype.subscribe = function (next, error, complete) { };\n    return ObservableMedia;\n}());\n/**\n * Class internalizes a MatchMedia service and exposes an Subscribable and Observable interface.\n * This an Observable with that exposes a feature to subscribe to mediaQuery\n * changes and a validator method (`isActive(<alias>)`) to test if a mediaQuery (or alias) is\n * currently active.\n *\n * !! Only mediaChange activations (not de-activations) are announced by the ObservableMedia\n *\n * This class uses the BreakPoint Registry to inject alias information into the raw MediaChange\n * notification. For custom mediaQuery notifications, alias information will not be injected and\n * those fields will be ''.\n *\n * !! This is not an actual Observable. It is a wrapper of an Observable used to publish additional\n * methods like `isActive(<alias>). To access the Observable and use RxJS operators, use\n * `.asObservable()` with syntax like media.asObservable().map(....).\n *\n *  \\@usage\n *\n *  // RxJS\n *  import 'rxjs/add/operator/filter';\n *  import { ObservableMedia } from '\\@angular/flex-layout';\n *\n *  \\@Component({ ... })\n *  export class AppComponent {\n *    status : string = '';\n *\n *    constructor(  media:ObservableMedia ) {\n *      let onChange = (change:MediaChange) => {\n *        this.status = change ? `'${change.mqAlias}' = (${change.mediaQuery})` : '';\n *      };\n *\n *      // Subscribe directly or access observable to use filter/map operators\n *      // e.g.\n *      //      media.subscribe(onChange);\n *\n *      media.asObservable()\n *        .filter((change:MediaChange) => true)   // silly noop filter\n *        .subscribe(onChange);\n *    }\n *  }\n */\nvar MediaService = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} breakpoints\n     * @param {?} mediaWatcher\n     */\n    function MediaService(breakpoints, mediaWatcher) {\n        this.breakpoints = breakpoints;\n        this.mediaWatcher = mediaWatcher;\n        /**\n         * Should we announce gt-<xxx> breakpoint activations ?\n         */\n        this.filterOverlaps = true;\n        this._registerBreakPoints();\n        this.observable$ = this._buildObservable();\n    }\n    /**\n     * Test if specified query/alias is active.\n     * @param {?} alias\n     * @return {?}\n     */\n    MediaService.prototype.isActive = function (alias) {\n        var /** @type {?} */ query = this._toMediaQuery(alias);\n        return this.mediaWatcher.isActive(query);\n    };\n    /**\n     * Proxy to the Observable subscribe method\n     * @param {?=} next\n     * @param {?=} error\n     * @param {?=} complete\n     * @return {?}\n     */\n    MediaService.prototype.subscribe = function (next, error, complete) {\n        return this.observable$.subscribe(next, error, complete);\n    };\n    /**\n     * Access to observable for use with operators like\n     * .filter(), .map(), etc.\n     * @return {?}\n     */\n    MediaService.prototype.asObservable = function () {\n        return this.observable$;\n    };\n    /**\n     * Register all the mediaQueries registered in the BreakPointRegistry\n     * This is needed so subscribers can be auto-notified of all standard, registered\n     * mediaQuery activations\n     * @return {?}\n     */\n    MediaService.prototype._registerBreakPoints = function () {\n        var /** @type {?} */ queries = this.breakpoints.sortedItems.map(function (bp) { return bp.mediaQuery; });\n        this.mediaWatcher.registerQuery(queries);\n    };\n    /**\n     * Prepare internal observable\n     *\n     * NOTE: the raw MediaChange events [from MatchMedia] do not\n     *       contain important alias information; as such this info\n     *       must be injected into the MediaChange\n     * @return {?}\n     */\n    MediaService.prototype._buildObservable = function () {\n        var _this = this;\n        var /** @type {?} */ self = this;\n        var /** @type {?} */ media$ = this.mediaWatcher.observe();\n        var /** @type {?} */ activationsOnly = function (change) {\n            return change.matches === true;\n        };\n        var /** @type {?} */ addAliasInformation = function (change) {\n            return mergeAlias(change, _this._findByQuery(change.mediaQuery));\n        };\n        var /** @type {?} */ excludeOverlaps = function (change) {\n            var /** @type {?} */ bp = _this.breakpoints.findByQuery(change.mediaQuery);\n            return !bp ? true : !(self.filterOverlaps && bp.overlapping);\n        };\n        /**\n         * Only pass/announce activations (not de-activations)\n         * Inject associated (if any) alias information into the MediaChange event\n         * Exclude mediaQuery activations for overlapping mQs. List bounded mQ ranges only\n         */\n        return media$.pipe(filter(activationsOnly), filter(excludeOverlaps), map(addAliasInformation));\n    };\n    /**\n     * Breakpoint locator by alias\n     * @param {?} alias\n     * @return {?}\n     */\n    MediaService.prototype._findByAlias = function (alias) {\n        return this.breakpoints.findByAlias(alias);\n    };\n    /**\n     * Breakpoint locator by mediaQuery\n     * @param {?} query\n     * @return {?}\n     */\n    MediaService.prototype._findByQuery = function (query) {\n        return this.breakpoints.findByQuery(query);\n    };\n    /**\n     * Find associated breakpoint (if any)\n     * @param {?} query\n     * @return {?}\n     */\n    MediaService.prototype._toMediaQuery = function (query) {\n        var /** @type {?} */ bp = this._findByAlias(query) || this._findByQuery(query);\n        return bp ? bp.mediaQuery : query;\n    };\n    return MediaService;\n}());\nvar ALIAS_DELIMITERS = /(\\.|-|_)/g;\n/**\n * @param {?} part\n * @return {?}\n */\nfunction firstUpperCase(part) {\n    var /** @type {?} */ first = part.length > 0 ? part.charAt(0) : '';\n    var /** @type {?} */ remainder = (part.length > 1) ? part.slice(1) : '';\n    return first.toUpperCase() + remainder;\n}\n/**\n * Converts snake-case to SnakeCase.\n * @param {?} name Text to UpperCamelCase\n * @return {?}\n */\nfunction camelCase(name) {\n    return name\n        .replace(ALIAS_DELIMITERS, '|')\n        .split('|')\n        .map(firstUpperCase)\n        .join('');\n}\n/**\n * For each breakpoint, ensure that a Suffix is defined;\n * fallback to UpperCamelCase the unique Alias value\n * @param {?} list\n * @return {?}\n */\nfunction validateSuffixes(list) {\n    list.forEach(function (bp) {\n        if (!bp.suffix || bp.suffix === '') {\n            bp.suffix = camelCase(bp.alias); // create Suffix value based on alias\n            bp.overlapping = bp.overlapping || false; // ensure default value\n        }\n    });\n    return list;\n}\n/**\n * Merge a custom breakpoint list with the default list based on unique alias values\n *  - Items are added if the alias is not in the default list\n *  - Items are merged with the custom override if the alias exists in the default list\n * @param {?} defaults\n * @param {?=} custom\n * @return {?}\n */\nfunction mergeByAlias(defaults, custom) {\n    if (custom === void 0) {\n        custom = [];\n    }\n    var /** @type {?} */ merged = defaults.map(function (bp) { return extendObject({}, bp); });\n    var /** @type {?} */ findByAlias = function (alias) {\n        return merged.reduce(function (result, bp) {\n            return result || ((bp.alias === alias) ? bp : null);\n        }, null);\n    };\n    // Merge custom breakpoints\n    custom.forEach(function (bp) {\n        var /** @type {?} */ target = findByAlias(bp.alias);\n        if (target) {\n            extendObject(target, bp);\n        }\n        else {\n            merged.push(bp);\n        }\n    });\n    return validateSuffixes(merged);\n}\n/**\n * Add new custom items to the default list or override existing default with custom overrides\n * @param {?=} _custom\n * @param {?=} options\n * @return {?}\n */\nfunction buildMergedBreakPoints(_custom, options) {\n    options = extendObject({}, {\n        defaults: true,\n        orientation: false // exclude pre-configured, internal orientations breakpoints\n    }, options || {});\n    return function () {\n        // Order so the defaults are loaded last; so ObservableMedia will report these last!\n        var /** @type {?} */ defaults = options.orientations ? ORIENTATION_BREAKPOINTS.concat(DEFAULT_BREAKPOINTS) :\n            DEFAULT_BREAKPOINTS;\n        return options.defaults ? mergeByAlias(defaults, _custom || []) : mergeByAlias(_custom);\n    };\n}\n/**\n *  Ensure that only a single global BreakPoint list is instantiated...\n * @return {?}\n */\nfunction DEFAULT_BREAKPOINTS_PROVIDER_FACTORY() {\n    return validateSuffixes(DEFAULT_BREAKPOINTS);\n}\n/**\n * Default Provider that does not support external customization nor provide\n * the extra extended breakpoints:   \"handset\", \"tablet\", and \"web\"\n *\n *  NOTE: !! breakpoints are considered to have unique 'alias' properties,\n *        custom breakpoints matching existing breakpoints will override the properties\n *        of the existing (and not be added as an extra breakpoint entry).\n *        [xs, gt-xs, sm, gt-sm, md, gt-md, lg, gt-lg, xl]\n */\nvar DEFAULT_BREAKPOINTS_PROVIDER = {\n    provide: BREAKPOINTS,\n    useFactory: DEFAULT_BREAKPOINTS_PROVIDER_FACTORY\n};\n/**\n * Use with FlexLayoutModule.CUSTOM_BREAKPOINTS_PROVIDER_FACTORY!\n * @param {?=} _custom\n * @param {?=} options\n * @return {?}\n */\nfunction CUSTOM_BREAKPOINTS_PROVIDER_FACTORY(_custom, options) {\n    return {\n        provide: BREAKPOINTS,\n        useFactory: buildMergedBreakPoints(_custom, options)\n    };\n}\n/**\n * Ensure a single global ObservableMedia service provider\n * @param {?} parentService\n * @param {?} matchMedia\n * @param {?} breakpoints\n * @return {?}\n */\nfunction OBSERVABLE_MEDIA_PROVIDER_FACTORY(parentService, matchMedia, breakpoints) {\n    return parentService || new MediaService(breakpoints, matchMedia);\n}\n/**\n *  Provider to return global service for observable service for all MediaQuery activations\n */\nvar OBSERVABLE_MEDIA_PROVIDER = {\n    provide: ObservableMedia,\n    deps: [\n        [new Optional(), new SkipSelf(), ObservableMedia],\n        MatchMedia,\n        BreakPointRegistry\n    ],\n    useFactory: OBSERVABLE_MEDIA_PROVIDER_FACTORY\n};\n/**\n * Ensure a single global service provider\n * @param {?} parentMonitor\n * @param {?} breakpoints\n * @param {?} matchMedia\n * @return {?}\n */\nfunction MEDIA_MONITOR_PROVIDER_FACTORY(parentMonitor, breakpoints, matchMedia) {\n    return parentMonitor || new MediaMonitor(breakpoints, matchMedia);\n}\n/**\n * Export provider that uses a global service factory (above)\n */\nvar MEDIA_MONITOR_PROVIDER = {\n    provide: MediaMonitor,\n    deps: [\n        [new Optional(), new SkipSelf(), MediaMonitor],\n        BreakPointRegistry,\n        MatchMedia,\n    ],\n    useFactory: MEDIA_MONITOR_PROVIDER_FACTORY\n};\n/**\n * *****************************************************************\n * Define module for the MediaQuery API\n * *****************************************************************\n */\nvar MediaQueriesModule = /*@__PURE__*/ (function () {\n    function MediaQueriesModule() {\n    }\n    return MediaQueriesModule;\n}());\n/**\n * Since the equivalent results are easily achieved with a css class attached to each\n * layout child, these have been deprecated and removed from the API.\n *\n *  import {LayoutPaddingDirective} from './api/flexbox/layout-padding';\n *  import {LayoutMarginDirective} from './api/flexbox/layout-margin';\n */\nvar ALL_DIRECTIVES = [\n    LayoutDirective,\n    LayoutWrapDirective,\n    LayoutGapDirective,\n    LayoutAlignDirective,\n    FlexDirective,\n    FlexOrderDirective,\n    FlexOffsetDirective,\n    FlexFillDirective,\n    FlexAlignDirective,\n    ShowHideDirective,\n    ClassDirective,\n    StyleDirective,\n    ImgSrcDirective\n];\n/**\n *\n */\nvar FlexLayoutModule = /*@__PURE__*/ (function () {\n    function FlexLayoutModule() {\n    }\n    /**\n     * External uses can easily add custom breakpoints AND include internal orientations\n     * breakpoints; which are not available by default.\n     *\n     * !! Selector aliases are not auto-configured. Developers must subclass\n     * the API directives to support extra selectors for the orientations breakpoints !!\n     * @param {?} breakpoints\n     * @param {?=} options\n     * @return {?}\n     */\n    FlexLayoutModule.provideBreakPoints = function (breakpoints, options) {\n        return {\n            ngModule: FlexLayoutModule,\n            providers: [\n                CUSTOM_BREAKPOINTS_PROVIDER_FACTORY(breakpoints, options || { orientations: false })\n            ]\n        };\n    };\n    return FlexLayoutModule;\n}());\n/**\n * Generated bundle index. Do not edit.\n */\nexport { VERSION, BaseFxDirective, BaseFxDirectiveAdapter, KeyOptions, ResponsiveActivation, LayoutDirective, LayoutAlignDirective, LayoutGapDirective, LayoutWrapDirective, FlexDirective, FlexAlignDirective, FlexFillDirective, FlexOffsetDirective, FlexOrderDirective, ClassDirective, StyleDirective, negativeOf, ShowHideDirective, ImgSrcDirective, RESPONSIVE_ALIASES, DEFAULT_BREAKPOINTS, ScreenTypes, ORIENTATION_BREAKPOINTS, BREAKPOINTS, BreakPointRegistry, ObservableMedia, MediaService, MatchMedia, isBrowser, MediaChange, MediaMonitor, buildMergedBreakPoints, DEFAULT_BREAKPOINTS_PROVIDER_FACTORY, DEFAULT_BREAKPOINTS_PROVIDER, CUSTOM_BREAKPOINTS_PROVIDER_FACTORY, OBSERVABLE_MEDIA_PROVIDER_FACTORY, OBSERVABLE_MEDIA_PROVIDER, MEDIA_MONITOR_PROVIDER_FACTORY, MEDIA_MONITOR_PROVIDER, MediaQueriesModule, mergeAlias, applyCssPrefixes, validateBasis, LAYOUT_VALUES, buildLayoutCSS, validateValue, isFlowHorizontal, validateWrapValue, validateSuffixes, mergeByAlias, extendObject, NgStyleKeyValue, ngStyleUtils, FlexLayoutModule };\n//# sourceMappingURL=flex-layout.es5.js.map\n",null]}