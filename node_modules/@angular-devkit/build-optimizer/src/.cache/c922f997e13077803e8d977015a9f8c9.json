{"remainingRequest":"D:\\Ramesh\\revere\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!D:\\Ramesh\\revere\\node_modules\\codemirror\\addon\\search\\searchcursor.js","dependencies":[{"path":"D:\\Ramesh\\revere\\node_modules\\codemirror\\addon\\search\\searchcursor.js","mtime":1527492762973},{"path":"D:\\Ramesh\\revere\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1527492760843},{"path":"D:\\Ramesh\\revere\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1527492734929}],"contextDependencies":[],"result":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n(function(mod) {\r\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\r\n    mod(require(\"../../lib/codemirror\"))\r\n  else if (typeof define == \"function\" && define.amd) // AMD\r\n    define([\"../../lib/codemirror\"], mod)\r\n  else // Plain browser env\r\n    mod(CodeMirror)\r\n})(function(CodeMirror) {\r\n  \"use strict\"\r\n  var Pos = CodeMirror.Pos\r\n\r\n  function regexpFlags(regexp) {\r\n    var flags = regexp.flags\r\n    return flags != null ? flags : (regexp.ignoreCase ? \"i\" : \"\")\r\n      + (regexp.global ? \"g\" : \"\")\r\n      + (regexp.multiline ? \"m\" : \"\")\r\n  }\r\n\r\n  function ensureFlags(regexp, flags) {\r\n    var current = regexpFlags(regexp), target = current\r\n    for (var i = 0; i < flags.length; i++) if (target.indexOf(flags.charAt(i)) == -1)\r\n      target += flags.charAt(i)\r\n    return current == target ? regexp : new RegExp(regexp.source, target)\r\n  }\r\n\r\n  function maybeMultiline(regexp) {\r\n    return /\\\\s|\\\\n|\\n|\\\\W|\\\\D|\\[\\^/.test(regexp.source)\r\n  }\r\n\r\n  function searchRegexpForward(doc, regexp, start) {\r\n    regexp = ensureFlags(regexp, \"g\")\r\n    for (var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, ch = 0) {\r\n      regexp.lastIndex = ch\r\n      var string = doc.getLine(line), match = regexp.exec(string)\r\n      if (match)\r\n        return {from: Pos(line, match.index),\r\n                to: Pos(line, match.index + match[0].length),\r\n                match: match}\r\n    }\r\n  }\r\n\r\n  function searchRegexpForwardMultiline(doc, regexp, start) {\r\n    if (!maybeMultiline(regexp)) return searchRegexpForward(doc, regexp, start)\r\n\r\n    regexp = ensureFlags(regexp, \"gm\")\r\n    var string, chunk = 1\r\n    for (var line = start.line, last = doc.lastLine(); line <= last;) {\r\n      // This grows the search buffer in exponentially-sized chunks\r\n      // between matches, so that nearby matches are fast and don't\r\n      // require concatenating the whole document (in case we're\r\n      // searching for something that has tons of matches), but at the\r\n      // same time, the amount of retries is limited.\r\n      for (var i = 0; i < chunk; i++) {\r\n        if (line > last) break\r\n        var curLine = doc.getLine(line++)\r\n        string = string == null ? curLine : string + \"\\n\" + curLine\r\n      }\r\n      chunk = chunk * 2\r\n      regexp.lastIndex = start.ch\r\n      var match = regexp.exec(string)\r\n      if (match) {\r\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\r\n        var startLine = start.line + before.length - 1, startCh = before[before.length - 1].length\r\n        return {from: Pos(startLine, startCh),\r\n                to: Pos(startLine + inside.length - 1,\r\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\r\n                match: match}\r\n      }\r\n    }\r\n  }\r\n\r\n  function lastMatchIn(string, regexp) {\r\n    var cutOff = 0, match\r\n    for (;;) {\r\n      regexp.lastIndex = cutOff\r\n      var newMatch = regexp.exec(string)\r\n      if (!newMatch) return match\r\n      match = newMatch\r\n      cutOff = match.index + (match[0].length || 1)\r\n      if (cutOff == string.length) return match\r\n    }\r\n  }\r\n\r\n  function searchRegexpBackward(doc, regexp, start) {\r\n    regexp = ensureFlags(regexp, \"g\")\r\n    for (var line = start.line, ch = start.ch, first = doc.firstLine(); line >= first; line--, ch = -1) {\r\n      var string = doc.getLine(line)\r\n      if (ch > -1) string = string.slice(0, ch)\r\n      var match = lastMatchIn(string, regexp)\r\n      if (match)\r\n        return {from: Pos(line, match.index),\r\n                to: Pos(line, match.index + match[0].length),\r\n                match: match}\r\n    }\r\n  }\r\n\r\n  function searchRegexpBackwardMultiline(doc, regexp, start) {\r\n    regexp = ensureFlags(regexp, \"gm\")\r\n    var string, chunk = 1\r\n    for (var line = start.line, first = doc.firstLine(); line >= first;) {\r\n      for (var i = 0; i < chunk; i++) {\r\n        var curLine = doc.getLine(line--)\r\n        string = string == null ? curLine.slice(0, start.ch) : curLine + \"\\n\" + string\r\n      }\r\n      chunk *= 2\r\n\r\n      var match = lastMatchIn(string, regexp)\r\n      if (match) {\r\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\r\n        var startLine = line + before.length, startCh = before[before.length - 1].length\r\n        return {from: Pos(startLine, startCh),\r\n                to: Pos(startLine + inside.length - 1,\r\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\r\n                match: match}\r\n      }\r\n    }\r\n  }\r\n\r\n  var doFold, noFold\r\n  if (String.prototype.normalize) {\r\n    doFold = function(str) { return str.normalize(\"NFD\").toLowerCase() }\r\n    noFold = function(str) { return str.normalize(\"NFD\") }\r\n  } else {\r\n    doFold = function(str) { return str.toLowerCase() }\r\n    noFold = function(str) { return str }\r\n  }\r\n\r\n  // Maps a position in a case-folded line back to a position in the original line\r\n  // (compensating for codepoints increasing in number during folding)\r\n  function adjustPos(orig, folded, pos, foldFunc) {\r\n    if (orig.length == folded.length) return pos\r\n    for (var min = 0, max = pos + Math.max(0, orig.length - folded.length);;) {\r\n      if (min == max) return min\r\n      var mid = (min + max) >> 1\r\n      var len = foldFunc(orig.slice(0, mid)).length\r\n      if (len == pos) return mid\r\n      else if (len > pos) max = mid\r\n      else min = mid + 1\r\n    }\r\n  }\r\n\r\n  function searchStringForward(doc, query, start, caseFold) {\r\n    // Empty string would match anything and never progress, so we\r\n    // define it to match nothing instead.\r\n    if (!query.length) return null\r\n    var fold = caseFold ? doFold : noFold\r\n    var lines = fold(query).split(/\\r|\\n\\r?/)\r\n\r\n    search: for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0) {\r\n      var orig = doc.getLine(line).slice(ch), string = fold(orig)\r\n      if (lines.length == 1) {\r\n        var found = string.indexOf(lines[0])\r\n        if (found == -1) continue search\r\n        var start = adjustPos(orig, string, found, fold) + ch\r\n        return {from: Pos(line, adjustPos(orig, string, found, fold) + ch),\r\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)}\r\n      } else {\r\n        var cutFrom = string.length - lines[0].length\r\n        if (string.slice(cutFrom) != lines[0]) continue search\r\n        for (var i = 1; i < lines.length - 1; i++)\r\n          if (fold(doc.getLine(line + i)) != lines[i]) continue search\r\n        var end = doc.getLine(line + lines.length - 1), endString = fold(end), lastLine = lines[lines.length - 1]\r\n        if (endString.slice(0, lastLine.length) != lastLine) continue search\r\n        return {from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),\r\n                to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))}\r\n      }\r\n    }\r\n  }\r\n\r\n  function searchStringBackward(doc, query, start, caseFold) {\r\n    if (!query.length) return null\r\n    var fold = caseFold ? doFold : noFold\r\n    var lines = fold(query).split(/\\r|\\n\\r?/)\r\n\r\n    search: for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1) {\r\n      var orig = doc.getLine(line)\r\n      if (ch > -1) orig = orig.slice(0, ch)\r\n      var string = fold(orig)\r\n      if (lines.length == 1) {\r\n        var found = string.lastIndexOf(lines[0])\r\n        if (found == -1) continue search\r\n        return {from: Pos(line, adjustPos(orig, string, found, fold)),\r\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))}\r\n      } else {\r\n        var lastLine = lines[lines.length - 1]\r\n        if (string.slice(0, lastLine.length) != lastLine) continue search\r\n        for (var i = 1, start = line - lines.length + 1; i < lines.length - 1; i++)\r\n          if (fold(doc.getLine(start + i)) != lines[i]) continue search\r\n        var top = doc.getLine(line + 1 - lines.length), topString = fold(top)\r\n        if (topString.slice(topString.length - lines[0].length) != lines[0]) continue search\r\n        return {from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),\r\n                to: Pos(line, adjustPos(orig, string, lastLine.length, fold))}\r\n      }\r\n    }\r\n  }\r\n\r\n  function SearchCursor(doc, query, pos, options) {\r\n    this.atOccurrence = false\r\n    this.doc = doc\r\n    pos = pos ? doc.clipPos(pos) : Pos(0, 0)\r\n    this.pos = {from: pos, to: pos}\r\n\r\n    var caseFold\r\n    if (typeof options == \"object\") {\r\n      caseFold = options.caseFold\r\n    } else { // Backwards compat for when caseFold was the 4th argument\r\n      caseFold = options\r\n      options = null\r\n    }\r\n\r\n    if (typeof query == \"string\") {\r\n      if (caseFold == null) caseFold = false\r\n      this.matches = function(reverse, pos) {\r\n        return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos, caseFold)\r\n      }\r\n    } else {\r\n      query = ensureFlags(query, \"gm\")\r\n      if (!options || options.multiline !== false)\r\n        this.matches = function(reverse, pos) {\r\n          return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos)\r\n        }\r\n      else\r\n        this.matches = function(reverse, pos) {\r\n          return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos)\r\n        }\r\n    }\r\n  }\r\n\r\n  SearchCursor.prototype = {\r\n    findNext: function() {return this.find(false)},\r\n    findPrevious: function() {return this.find(true)},\r\n\r\n    find: function(reverse) {\r\n      var result = this.matches(reverse, this.doc.clipPos(reverse ? this.pos.from : this.pos.to))\r\n\r\n      // Implements weird auto-growing behavior on null-matches for\r\n      // backwards-compatiblity with the vim code (unfortunately)\r\n      while (result && CodeMirror.cmpPos(result.from, result.to) == 0) {\r\n        if (reverse) {\r\n          if (result.from.ch) result.from = Pos(result.from.line, result.from.ch - 1)\r\n          else if (result.from.line == this.doc.firstLine()) result = null\r\n          else result = this.matches(reverse, this.doc.clipPos(Pos(result.from.line - 1)))\r\n        } else {\r\n          if (result.to.ch < this.doc.getLine(result.to.line).length) result.to = Pos(result.to.line, result.to.ch + 1)\r\n          else if (result.to.line == this.doc.lastLine()) result = null\r\n          else result = this.matches(reverse, Pos(result.to.line + 1, 0))\r\n        }\r\n      }\r\n\r\n      if (result) {\r\n        this.pos = result\r\n        this.atOccurrence = true\r\n        return this.pos.match || true\r\n      } else {\r\n        var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0)\r\n        this.pos = {from: end, to: end}\r\n        return this.atOccurrence = false\r\n      }\r\n    },\r\n\r\n    from: function() {if (this.atOccurrence) return this.pos.from},\r\n    to: function() {if (this.atOccurrence) return this.pos.to},\r\n\r\n    replace: function(newText, origin) {\r\n      if (!this.atOccurrence) return\r\n      var lines = CodeMirror.splitLines(newText)\r\n      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin)\r\n      this.pos.to = Pos(this.pos.from.line + lines.length - 1,\r\n                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0))\r\n    }\r\n  }\r\n\r\n  CodeMirror.defineExtension(\"getSearchCursor\", function(query, pos, caseFold) {\r\n    return new SearchCursor(this.doc, query, pos, caseFold)\r\n  })\r\n  CodeMirror.defineDocExtension(\"getSearchCursor\", function(query, pos, caseFold) {\r\n    return new SearchCursor(this, query, pos, caseFold)\r\n  })\r\n\r\n  CodeMirror.defineExtension(\"selectMatches\", function(query, caseFold) {\r\n    var ranges = []\r\n    var cur = this.getSearchCursor(query, this.getCursor(\"from\"), caseFold)\r\n    while (cur.findNext()) {\r\n      if (CodeMirror.cmpPos(cur.to(), this.getCursor(\"to\")) > 0) break\r\n      ranges.push({anchor: cur.from(), head: cur.to()})\r\n    }\r\n    if (ranges.length)\r\n      this.setSelections(ranges, 0)\r\n  })\r\n});\r\n",null]}