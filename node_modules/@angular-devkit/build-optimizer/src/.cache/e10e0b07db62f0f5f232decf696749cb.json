{"remainingRequest":"D:\\Ramesh\\revere\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!D:\\Ramesh\\revere\\node_modules\\angular2-moment\\calendar.pipe.js","dependencies":[{"path":"D:\\Ramesh\\revere\\node_modules\\angular2-moment\\calendar.pipe.js","mtime":1527492759789},{"path":"D:\\Ramesh\\revere\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1527492760843},{"path":"D:\\Ramesh\\revere\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1527492734929}],"contextDependencies":[],"result":["\"use strict\";\nvar __decorate = /*@__PURE__*/ require(\"tslib\").__decorate;\nvar __metadata = /*@__PURE__*/ require(\"tslib\").__metadata;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_1 = require(\"@angular/core\");\nvar moment = require(\"moment\");\n// under systemjs, moment is actually exported as the default export, so we account for that\nvar momentConstructor = moment.default || moment;\nvar CalendarPipe = /*@__PURE__*/ (function () {\n    function CalendarPipe(cdRef, ngZone) {\n        var _this = this;\n        this.cdRef = cdRef;\n        this.ngZone = ngZone;\n        // using a single static timer for all instances of this pipe for performance reasons\n        CalendarPipe_1.initTimer(ngZone);\n        CalendarPipe_1.refs++;\n        // values such as Today will need to be replaced with Yesterday after midnight,\n        // so make sure we subscribe to an EventEmitter that we set up to emit at midnight\n        this.midnightSub = CalendarPipe_1.midnight.subscribe(function () {\n            _this.ngZone.run(function () { return _this.cdRef.markForCheck(); });\n        });\n    }\n    CalendarPipe_1 = CalendarPipe;\n    CalendarPipe.prototype.transform = function (value) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        var formats = null;\n        var referenceTime = null;\n        for (var i = 0, len = args.length; i < len; i++) {\n            if (args[i] !== null) {\n                if (typeof args[i] === 'object' && !moment.isMoment(args[i])) {\n                    formats = args[i];\n                }\n                else {\n                    referenceTime = momentConstructor(args[i]);\n                }\n            }\n        }\n        return momentConstructor(value).calendar(referenceTime, formats);\n    };\n    CalendarPipe.prototype.ngOnDestroy = function () {\n        if (CalendarPipe_1.refs > 0) {\n            CalendarPipe_1.refs--;\n        }\n        if (CalendarPipe_1.refs === 0) {\n            CalendarPipe_1.removeTimer();\n        }\n        this.midnightSub.unsubscribe();\n    };\n    CalendarPipe.initTimer = function (ngZone) {\n        // initialize the timer\n        if (!CalendarPipe_1.midnight) {\n            CalendarPipe_1.midnight = new core_1.EventEmitter();\n            if (typeof window !== 'undefined') {\n                var timeToUpdate_1 = CalendarPipe_1._getMillisecondsUntilUpdate();\n                CalendarPipe_1.timer = ngZone.runOutsideAngular(function () {\n                    return window.setTimeout(function () {\n                        // emit the current date\n                        CalendarPipe_1.midnight.emit(new Date());\n                        // refresh the timer\n                        CalendarPipe_1.removeTimer();\n                        CalendarPipe_1.initTimer(ngZone);\n                    }, timeToUpdate_1);\n                });\n            }\n        }\n    };\n    CalendarPipe.removeTimer = function () {\n        if (CalendarPipe_1.timer) {\n            window.clearTimeout(CalendarPipe_1.timer);\n            CalendarPipe_1.timer = null;\n            CalendarPipe_1.midnight = null;\n        }\n    };\n    CalendarPipe._getMillisecondsUntilUpdate = function () {\n        var now = momentConstructor();\n        var tomorrow = momentConstructor().startOf('day').add(1, 'days');\n        var timeToMidnight = tomorrow.valueOf() - now.valueOf();\n        return timeToMidnight + 1000; // 1 second after midnight\n    };\n    /**\n     * @private Internal reference counter, so we can clean up when no instances are in use\n     * @type {number}\n     */\n    CalendarPipe.refs = 0;\n    CalendarPipe = CalendarPipe_1 = __decorate([\n        core_1.Pipe({ name: 'amCalendar', pure: false })\n    ], CalendarPipe);\n    return CalendarPipe;\n    var CalendarPipe_1;\n}());\nexports.CalendarPipe = CalendarPipe;\n",null]}